<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[笔记] 当在 Vue 中不得不用全局样式时...</title>
    <url>/Note/%E7%AC%94%E8%AE%B0-%E5%BD%93%E5%9C%A8-Vue-%E4%B8%AD%E4%B8%8D%E5%BE%97%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E6%97%B6/</url>
    <content><![CDATA[<p>有时候基于 Vue 的单文件组件开发项目时, 不得不使用全局样式, 这时有一些需要注意的地方.</p>
<a id="more"></a>
<p>当遇到需要使用全局样式时, 下列几种情况</p>
<ul>
<li>样式在项目各处均有使用;</li>
<li>样式只在当前组件内的 DOM 上使用;</li>
<li>样式需要应用到当前组件 DOM 的外部 DOM;</li>
</ul>
<p>下面详细记录一下需要注意的问题:</p>
<h3 id="样式在项目各处均有使用"><a href="#样式在项目各处均有使用" class="headerlink" title="样式在项目各处均有使用"></a>样式在项目各处均有使用</h3><p>如果样式需要在项目各处均有使用, 例如: <a href="http://meyerweb.com/eric/tools/css/reset/" target="_blank" rel="noopener">reset.css</a>, <a href="https://github.com/BearD01001/tiny-trim.css" target="_blank" rel="noopener">tiny-trim.css</a> 等等.<br>这时推荐在项目入口文件中直接导入样式文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'tiny-trim.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'asset/reset.css'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'asset/global.css'</span></span><br></pre></td></tr></table></figure>
<p>当然, 也可以在顶层组件中没有设置 <code>scoped</code> 属性的 <code>style</code> 标签中导入:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(asset/reset.css);</span><br><span class="line"><span class="keyword">@import</span> url(asset/global.css);</span><br></pre></td></tr></table></figure>
<h3 id="样式只在当前组件内的-DOM-上使用"><a href="#样式只在当前组件内的-DOM-上使用" class="headerlink" title="样式只在当前组件内的 DOM 上使用"></a>样式只在当前组件内的 DOM 上使用</h3><p>当使用一些第三方 UI 库时, 有一些 UI 库生成的 DOM 在 <code>template</code> 中并不能直接添加 <code>class</code> 或 <code>style</code> 来修改第三方 UI 库的组件样式, 这时我们可以通过当前组件没有 <code>scoped</code> 属性的 <code>style</code> 标签来添加全局样式.</p>
<p>但此时需要考虑一些问题:</p>
<ul>
<li>这个样式应该只影响<strong>当前组件</strong>内第三方 UI 库渲染出来的 DOM</li>
<li>因为 DOM 不在 <code>template</code> 标签里 (DOM 由第三方 UI 库的 JS 在浏览器加载时构建或在编译打包过程中生成), 不能直接设置 <code>class</code> 或 <code>style</code> 来修改样式, 故只能使用没有 <code>scoped</code> 属性的 <code>style</code> 标签</li>
</ul>
<p>可以看出两点是有一定矛盾的. 不过可以采用如下方法解决或缓解:</p>
<ol>
<li><p>为当前组件根元素设置自定义 <code>data</code> 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/components/MyComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-component"</span> <span class="attr">data-custom-mycomponent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tempalte</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在没有 <code>scoped</code> 属性的 <code>style</code> 标签中使用自定义 <code>data</code> 属性限定样式作用域</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.my-component</span><span class="selector-attr">[data-custom-mycomponent]</span> &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里推荐使用 <code>Less</code> 或 <code>Sass</code>, 嵌套语法能减少许多代码冗余.</p>
</blockquote>
</li>
</ol>
<h3 id="样式需要应用到当前组件-DOM-的外部-DOM"><a href="#样式需要应用到当前组件-DOM-的外部-DOM" class="headerlink" title="样式需要应用到当前组件 DOM 的外部 DOM"></a>样式需要应用到当前组件 DOM 的外部 DOM</h3><p>这种情况主要是针对上一种情况的补充, 有时候第三方 UI 库生成的 DOM 节点并不在当前组件的 DOM 内, 可能渲染到 <code>body</code> 中 (如 <code>dialog</code>, <code>tooltip</code>, <code>message</code> 等).</p>
<p>这些渲染到当前组件 <code>DOM</code> 之外的组件, 需要在上一种情况的处理基础上, 为它们的顶层元素再设置一个自定义的 <code>data</code> 属性:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/components/MyComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"my-component"</span> <span class="attr">data-custom-mycomponent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- message 组件的 DOM 将被渲染到 body 中, 而不是当前组件 .my-component 中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"my-component-message"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">msg</span>=<span class="string">"You got a message! "</span></span></span><br><span class="line"><span class="tag">      <span class="attr">data-custom-mycomponent-message</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tempalte</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.my-component</span><span class="selector-attr">[data-custom-mycomponent]</span> &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my-component-message</span><span class="selector-attr">[data-custom-mycomponent-message]</span> &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-EOF</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>CSS</tag>
        <tag>scoped</tag>
      </tags>
  </entry>
  <entry>
    <title>深度定制团队自己的 Vue template</title>
    <url>/JavaScript/%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6%E5%9B%A2%E9%98%9F%E8%87%AA%E5%B7%B1%E7%9A%84-Vue-template/</url>
    <content><![CDATA[<p>众所周知，使用 <code>vue-cli</code> 可以快速初始化一个基于 <code>Vue.js</code> 的项目，官方提供了 <code>webpack</code>、<code>pwa</code>、<code>browserify-simple</code> 等<a href="https://github.com/vuejs-templates" target="_blank" rel="noopener">常用 templates</a>。</p>
<p>当开发一个独立项目的时候，使用官方提供的 <code>template</code> 确实非常方便，省去了繁琐的依赖安装配置、<code>webpack</code> 配置，甚至连项目结构也不用多加考虑。</p>
<p>但是，当我们需要开发多个系统，每个系统相对独立但又有一些配置、依赖或逻辑相互通用的时候（例如集群的多后台系统），每次使用官方提供的 <code>template</code> 初始化项目之后，都需要进一步调整（添加依赖、修改配置、增加通用组件等等），这显然是十分麻烦的。<br>本着<del>懒惰是第一生产力</del>的初衷，我们需要定制一份自己的 <code>template</code>，以便我们…额…偷懒哈~<br><img src="/JavaScript/深度定制团队自己的-Vue-template/hehe.jpg" alt></p>
<a id="more"></a>
<p>在开始定制我们自己的 <code>Vue template</code> 前，我们需要了解一些前置知识：</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a><strong>前置知识</strong></h3><ol>
<li><p>模板结构<br>　　首先我们先来了解模板的主要结构，模板结构很简单，主要包括两个部分：</p>
<ul>
<li>template 该目录用于存放模板文件，初始化项目生成的文件来自于此。</li>
<li>meta.js / meta.json 用于描述初始化项目时命令行的交互动作。</li>
</ul>
</li>
<li><p><a href="https://github.com/segmentio/metalsmith" target="_blank" rel="noopener">Metalsmith</a><br>　　<code>Metalsmith</code> 在渲染项目文件流程中角色相当于 <code>gulp.js</code>，可以通过添加一些插件对构建文件进行处理，如重命名、合并等。</p>
</li>
<li><p><a href="https://github.com/flipxfx/download-git-repo" target="_blank" rel="noopener">download-git-repo</a><br>　　使用 <code>vue-cli</code> 初始化项目时会使用该工具来下载目标仓库。默认的 <code>webpack</code> 等模板直接下载 <code>vue-templates</code> 中对应的模板仓库。<br>　　自定义的模板也可以是一个 GitHub 仓库，使用如下命令来初始化项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue init username/repo my-project</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 <code>username</code> 为自定义模板仓库所在的 GitHub 用户或组织名，<code>repo</code> 为仓库名。</p>
</blockquote>
</li>
<li><p><a href="https://github.com/SBoudrias/Inquirer.js#question" target="_blank" rel="noopener">Inquirer.js</a><br>　　<code>vue-cli</code> 在模板仓库下载完成后，将通过 <code>Inquirer.js</code> 根据模板仓库中的 <code>meta.js</code> 或 <code>meta.json</code> 文件中的设置，与用户进行一些简单的交互以确定项目的一些细节，如下图：<br><img src="/JavaScript/深度定制团队自己的-Vue-template/cli-perview.png" alt></p>
<blockquote>
<p>该交互配置是可选的，当项目中<strong>没有</strong> <code>meta.js</code> 或 <code>meta.json</code> 文件时，模板仓库下载完成后将直接进入模板构建阶段。</p>
</blockquote>
</li>
<li><p><a href="https://github.com/wycats/handlebars.js/" target="_blank" rel="noopener">Handlebars.js</a><br>　　在通过命令行交互确定了项目初始化的细节后，就该进入最后一道工序，按照模板初始化我们的项目啦！\(≧▽≦)/<br>　　这里 <code>vue-cli</code> 选用的是 <code>Handlebars.js</code> —— 一个简单高效的语义化模板构建引擎。</p>
</li>
</ol>
<p>　　画了一张图，更有助于理清这些依赖在 <code>vue-cli</code> 初始化项目时的相互关联：<br><img src="/JavaScript/深度定制团队自己的-Vue-template/vue-cli-process.png" alt="vue-cli process"></p>
<blockquote>
<p>定制模板主要围绕着<strong>命令行交互</strong>（<code>Inquirer.js</code>）与<strong>模板文件开发</strong>（<code>Handlebars.js</code>）这两部分。</p>
</blockquote>
<h3 id="meta-js-配置文件（Inquirer-js）"><a href="#meta-js-配置文件（Inquirer-js）" class="headerlink" title="meta.js 配置文件（Inquirer.js）"></a>meta.js 配置文件（Inquirer.js）</h3><p>　　由于 <code>meta.js</code> 相当于模板项目的配置文件（虽然非必选），所以这里先看看它主要能干些啥。<br>　　设置都在 <code>meta.js</code> 或 <code>meta.json</code> 中配置，推荐使用 <code>meta.js</code>，更灵活一些。以下也将以 <code>meta.js</code> 进行展开说明。<br>　　<code>meta.js</code> 一共可包含如下几个字段，简单列一下各字段功能：</p>
<ul>
<li><code>helpers</code> : 自定义 <code>Handlebars.js</code> 的辅助函数</li>
<li><code>prompts</code> : 基于 <code>Inquirer.js</code> 的命令行交互配置</li>
<li><code>filters</code> : 根据命令行交互的结果过滤将要渲染的项目文件</li>
<li><code>metalsmith</code> : 配置 <code>Metalsmith</code> 插件，文件会像 <code>gulp.js</code> 中的 <code>pipe</code> 一样依次经过各个插件处理</li>
<li><code>completeMessage</code> : 将模板渲染为项目后，输出一些提示信息，取值为字符串</li>
<li><code>complete</code> : 与 <code>completeMessage</code> 功能相同，二选其一，取值为函数，函数最后需返回输出的字符串</li>
</ul>
<h3 id="命令行交互（Inquirer-js）"><a href="#命令行交互（Inquirer-js）" class="headerlink" title="命令行交互（Inquirer.js）"></a>命令行交互（Inquirer.js）</h3><p>　　命令行交互主要是 <code>meta.js</code> 中 <code>prompts</code> 字段的配置，详细的配置可以阅读 <code>Inquirer.js</code> 的 <a href="https://github.com/SBoudrias/Inquirer.js/#question" target="_blank" rel="noopener">README.md</a>，这里说一下常用的交互配置：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// meta.js</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"prompts"</span>: &#123;</span><br><span class="line">    <span class="string">"isCustomName"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>   : <span class="string">"confirm"</span>,</span><br><span class="line">      <span class="string">"message"</span>: <span class="string">"是否自定义系统名称？"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"sysName"</span>: &#123;</span><br><span class="line">      <span class="string">"type"</span>    : <span class="string">"input"</span>,</span><br><span class="line">      <span class="string">"when"</span>    : <span class="string">"isCustomName"</span>,</span><br><span class="line">      <span class="string">"default"</span> : <span class="string">"默认系统名称"</span>,</span><br><span class="line">      <span class="string">"message"</span> : <span class="string">"请输入系统名称:"</span>,</span><br><span class="line">      <span class="string">"required"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"validate"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!val) <span class="keyword">return</span> <span class="string">'(✘) 请输入系统名称，该名称将设为 index.html 的 title'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字段说明：</p>
<ul>
<li><code>isCustomName</code> 与 <code>sysName</code> : 交互字段名称，<strong>可在后续条件交互或模板渲染时通过该字段读取到交互结果</strong></li>
<li><code>type</code> : 交互类型，有 <code>input</code>, <code>confirm</code>, <code>list</code>, <code>rawlist</code>, <code>expand</code>, <code>checkbox</code>, <code>password</code>, <code>editor</code> 八种类型</li>
<li><code>message</code> : 交互的提示信息</li>
<li><code>when</code> : 进行该条件交互的先决条件，在该例子中，<code>sysName</code> 这个交互动作只在 <code>isCustomName</code> 交互结果为真时才会出现</li>
<li><code>default</code> : 默认值，当用户输入为空时，交互结果即为此值</li>
<li><code>required</code> : 默认为 <code>false</code>，该值是否为必填项</li>
<li><code>validate</code> : 输入验证函数</li>
</ul>
<blockquote>
<p>注：示例中 <code>default</code> <code>required</code> <code>validate</code> 三个字段存在逻辑问题，仅为举例方便放到一起。</p>
</blockquote>
<h3 id="模板基本语法（Handlebars-js）"><a href="#模板基本语法（Handlebars-js）" class="headerlink" title="模板基本语法（Handlebars.js）"></a>模板基本语法（Handlebars.js）</h3><p>　　在模板编写中，我们可以用 <code>Mustache</code> 语法在任何文本类型的文件中输出在命令行交互中得到的一些数据：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dev.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  token: <span class="string">'&#123;&#123;token&#125;&#125;'</span>,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;sysName&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　以 <code>{{xxx}}</code> 即为一个 <code>Mustache</code> 句法标记。以上例子中 <code>token</code> 与 <code>sysName</code> 为匹配命令行交互数据对应的键名。</p>
<blockquote>
<p>对 <code>vue</code> 有过了解的都知道，在模板标签中直接输出实例上的数据也是用的 <code>Mustache</code> 语法。<br>如果定制 <code>vue template</code> 模板时不对这些数据做相应处理，在最终输出由模板初始化的项目时，这些与命令行交互得到的数据无法匹配的 <code>Mustache</code> 句法标记会被移除。<br>此时我们需要使用反斜杠 <code>\{{xxx}}</code> 或者 <code>{{{xxx}}}</code> 来跳过 <code>Handlebars</code> 的处理，直接输出 <code>{{xxx}}</code></p>
</blockquote>
<h3 id="模板渲染时的辅助函数（Handlebars-js）"><a href="#模板渲染时的辅助函数（Handlebars-js）" class="headerlink" title="模板渲染时的辅助函数（Handlebars.js）"></a>模板渲染时的辅助函数（Handlebars.js）</h3><p>　　<code>vue-cli</code> 中为 <code>Handlebars</code> 预置了 <code>if_eq</code> 与 <code>unless_eq</code> 辅助函数，用于使用交互所得数据来处理模板中是否渲染的两种逻辑关系，此外 <code>Handlebars</code> 中还内置了 <code>if</code>、<code>unless</code>、<code>each</code> 等 <a href="http://handlebarsjs.com/builtin_helpers.html" target="_blank" rel="noopener">辅助函数</a>。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sys.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  &#123;&#123;#if_eq projType 'admin'&#125;&#125;</span><br><span class="line">  id: &#123;&#123;#if_eq sysId ''&#125;&#125;undefined&#123;&#123;else&#125;&#125;&#123;&#123;sysId&#125;&#125;&#123;&#123;/if_eq&#125;&#125;,</span><br><span class="line">  &#123;&#123;/if_eq&#125;&#125;</span><br><span class="line">  name: <span class="string">'&#123;&#123;sysName&#125;&#125;'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>　　如上，这里用了 <code>if_eq</code> 辅助函数，<code>projType</code> 代表将要匹配的键，<code>&#39;admin&#39;</code> 代表将要匹配的值。这个键值来自于在命令行界面与用户交互的操作结果。该栗子中，当命令行交互数据中 <code>CLI[projType] == &#39;admin&#39;</code> 时，将在 <code>sys.js</code> 文件的导出数据中输出 <code>id</code> 字段；<code>id</code> 的值来自一个嵌套的 <code>if_eq</code> 辅助函数，当 <code>CLI[sysId] == &#39;&#39;</code> 时，<code>id</code> 将被设置为 <code>undefined</code> 否则 （<code>{{else}}</code>）输出 <code>CLI[sysId]</code> 命令行交互所得数据中的 <code>sysId</code>。</p>
<blockquote>
<p>辅助函数使用语法： <code>{{#</code> + <code>函数名</code> + ‘ ‘（空格）+ <code>以空格分隔的参数列表</code> + <code>}}</code><br>以空格分隔的参数列表：未用引号包裹的参数名将被将为自动取值为命令行交互结果中对应的数据</p>
</blockquote>
<h3 id="自定义辅助函数（Handlebars-js）"><a href="#自定义辅助函数（Handlebars-js）" class="headerlink" title="自定义辅助函数（Handlebars.js）"></a>自定义辅助函数（Handlebars.js）</h3><p>　　有时候现有的辅助函数可能不能满足我们的需求，通过 <code>mate.js</code> 中的 <code>helpers</code> 字段我们可以自定义辅助函数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mate.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"helpers"</span>: &#123;</span><br><span class="line">    <span class="string">"neither"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">k, v1, v2, options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (k !== v1 &amp;&amp; k !== v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> options.fn(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> options.inverse(<span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　辅助函数可以接受若干的参数，最后一个参数 <code>options</code> 为辅助函数的钩子，调用 <code>options.fn(this)</code> 即输出该辅助函数运算结果为真时的内容，反之调用 <code>options.inverse(this)</code> 则输出 <code>{{else}}</code> 的内容（如果有的话）。<br>　　现在我们可以在模板中直接使用 <code>neither</code> 辅助函数了：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;#neigher sysType 'admin' 'mobile'&#125;&#125;</span><br><span class="line">isAdmin  = <span class="literal">false</span></span><br><span class="line">isMobile = <span class="literal">false</span></span><br><span class="line">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span><br><span class="line">isAdminOrMobile = <span class="literal">true</span></span><br><span class="line">&#123;&#123;/neigher&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="按条件过滤渲染文件"><a href="#按条件过滤渲染文件" class="headerlink" title="按条件过滤渲染文件"></a>按条件过滤渲染文件</h3><p>　　辅助函数只可以控制文件内一部分内容的输出与否，有时候我们需要根据交互结果控制某些文件本身是否输出。<br>　　在 <code>mate.js</code> 中的 <code>filters</code> 字段中进行相应的设置，就可以达到控制文件输出的效果：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">"filters"</span>: &#123;</span><br><span class="line">    <span class="string">"project/config/test.env.js"</span>: <span class="string">"unit || e2e"</span>,</span><br><span class="line">    <span class="string">"project/src/router/**/*"</span>: <span class="string">"router"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　<code>filters</code> 中<strong>键名</strong>是要控制输出的文件的路径，可使用字面量，也可使用 <a href="https://github.com/isaacs/minimatch" target="_blank" rel="noopener">简化的 glob 表达式</a>。键名对应的值为命令行交互中得到的数据。</p>
<h3 id="渲染时文件的操作"><a href="#渲染时文件的操作" class="headerlink" title="渲染时文件的操作"></a>渲染时文件的操作</h3><p>　　在模板项目比较复杂或是有特殊需求的时候，比如：</p>
<ul>
<li>按照条件不同需要渲染两个文件名相同但内容完全不同的文件</li>
<li>模板模块化，多个模板文件拼接渲染为一个项目文件</li>
<li>使用 GZip 压缩一些非源码资源</li>
</ul>
<p>　　可以通过 <code>mate.js</code> 中的 <code>metalsmith</code> 字段配置相关插件来实现丰富的文件操作：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> renamer = <span class="built_in">require</span>(<span class="string">'metalsmith-renamer'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">"metalsmith"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">metalsmith, opts, helpers</span>) </span>&#123;</span><br><span class="line">    metalsmith.use(renamer(&#123;</span><br><span class="line">      index: &#123;</span><br><span class="line">        pattern: <span class="string">'project/**/+(Mobile|Admin)Index.vue'</span>,</span><br><span class="line">        rename: <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'Index.vue'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      config: &#123;</span><br><span class="line">        pattern: <span class="string">'project/src/+(mobile|admin)Config.js'</span>,</span><br><span class="line">        rename: <span class="string">'config.js'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　 以上是 <code>metalsmith-renamer</code> 插件的简单使用，更多插件可以在<a href="http://www.metalsmith.io/#the-community-plugins" target="_blank" rel="noopener">这里</a>查找</p>
<blockquote>
<p>使用 <code>metalsmith</code> 插件请注意：由于 <code>vue-cli</code> 在下载完成模板仓库后并没有 <code>npm install</code> 安装模板的项目依赖这一操作，所以在打包模板仓库的时候也需要将依赖目录 <code>node_modules</code> 一同打包，<code>metalsmith</code> 的插件都很精简，一般不会有什么嵌套依赖。不过还是建议在使用前查看一下插件的相关 <code>Github</code> 仓库。</p>
</blockquote>
<p>　　关于 <code>vue</code> 项目模板的开发涉及到的问题差不多就介绍完了，为自己或团队开发一份专属的 <code>Vue Template</code> 吧！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
        <tag>vue-cli</tag>
        <tag>vue-template</tag>
      </tags>
  </entry>
  <entry>
    <title>VueJS 开发常见问题集锦</title>
    <url>/JavaScript/VueJS-%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<p>由于公司的前端开始转向 <code>VueJS</code>，最近开始使用这个框架进行开发，遇到一些问题记录下来，以备后用。</p>
<p>主要写一些 <strong><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">官方手册</a></strong> 上没有写，但是实际开发中会遇到的问题，需要一定知识基础。</p>
<hr>
<h3 id="涉及技术栈"><a href="#涉及技术栈" class="headerlink" title="涉及技术栈"></a>涉及技术栈</h3><ul>
<li>CLI: <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">Vue-CLI</a></li>
<li>UI: <a href="http://element.eleme.io/" target="_blank" rel="noopener">Element</a></li>
<li>HTML: <a href="https://pugjs.org/" target="_blank" rel="noopener">Pug(Jade)</a></li>
<li>CSS: <a href="http://lesscss.org/" target="_blank" rel="noopener">Less</a></li>
<li>JavaScript: <a href="https://github.com/lukehoban/es6features" target="_blank" rel="noopener">ES6</a></li>
</ul>
<hr>
<p><strong>正文：</strong></p>
<h3 id="polyfill-与-transform-runtime"><a href="#polyfill-与-transform-runtime" class="headerlink" title="polyfill 与 transform-runtime"></a>polyfill 与 transform-runtime</h3><p>　　首先，<code>vue-cli</code> 为我们自动添加了 <code>babel-plugin-transform-runtime</code> 这个插件，该插件多数情况下都运作正常，可以转换大部分 <code>ES6</code> 语法。</p>
<p>　　但是，存在如下两个问题：</p>
<ol>
<li><strong>异步加载组件时，会产生 <code>polyfill</code> 代码冗余</strong></li>
<li><strong>不支持对全局函数与实例方法的 <code>polyfill</code></strong></li>
</ol>
<p>　　两个问题的原因均归因于 <code>babel-plugin-transform-runtime</code> 采用了沙箱机制来编译我们的代码（即：不修改宿主环境的内置对象）。</p>
<p>　　由于异步组件最终会被编译为一个单独的文件，所以即使多个组件中使用了同一个新特性（例如：<code>Object.keys()</code>），那么在每个编译后的文件中都会有一份该新特性的 <code>polyfill</code> 拷贝。如果项目较小可以考虑不使用异步加载，但是首屏的压力会比较大。</p>
<p>　　<strong>不支持全局函数</strong>（如：<code>Promise</code>、<code>Set</code>、<code>Map</code>），<code>Set</code> 跟 <code>Map</code> 这两种数据结构应该大家用的也不多，影响较小。但是 <code>Promise</code> 影响可能就比较大了。</p>
<p>　　<strong>不支持实例方法</strong>（如：<code>&#39;abc&#39;.includes(&#39;b&#39;)</code>、<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].find((n) =&gt; n &lt; 2)</code> 等等），这个限制几乎废掉了大部分字符串和一半左右数组的新特性。</p>
<blockquote>
<p>一般情况下 <code>babel-plugin-transform-runtime</code> 能满足大部分的需求，当不满足需求时，推荐使用完整的 <code>babel-polyfill</code>。</p>
</blockquote>
<h4 id="替换-babel-polyfill"><a href="#替换-babel-polyfill" class="headerlink" title="替换 babel-polyfill"></a>替换 babel-polyfill</h4><p>　　首先，从项目中移除 <code>babel-plugin-transform-runtime</code><br>　　卸载该依赖：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm un babel-plugin-transform-runtime -D</span><br></pre></td></tr></table></figure></p>
<p>　　修改 <code>babel</code> 配置文件<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="comment">// - "transform-runtime"</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　然后，安装 <code>babel-polyfill</code> 依赖：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i babel-polyfill -D</span><br></pre></td></tr></table></figure></p>
<p>　　最后，在入口文件中导入<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="ES6-import-引用问题"><a href="#ES6-import-引用问题" class="headerlink" title="ES6 import 引用问题"></a>ES6 import 引用问题</h3><p>　　在 <code>ES6</code> 中，模块系统的导入与导出采用的是引用导出与导入（非简单数据类型），也就是说，如果在一个模块中定义了一个对象并导出，在其他模块中导入使用时，导入的其实是一个变量引用（指针），如果修改了对象中的属性，会影响到其他模块的使用。</p>
<p>　　通常情况下，系统体量不大时，我们可以使用 <code>JSON.parse(JSON.stringify(str))</code> 简单粗暴地来生成一个全新的深度拷贝的 <strong>数据对象</strong>。不过当组件较多、数据对象复用程度较高时，很明显会产生性能问题，这时我们可以考虑使用 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">Immutable.js</a>。</p>
<blockquote>
<p>鉴于这个原因，进行复杂数据类型的导出时，需要注意多个组件导入同一个数据对象时修改数据后可能产生的问题。<br>此外，模块定义变量或函数时即便使用 <code>let</code> 而不是 <code>const</code>，在导入使用时都会变成只读，不能重新赋值，效果等同于用 <code>const</code> 声明。</p>
</blockquote>
<h3 id="在-Vue-中使用-Pug-与-Less"><a href="#在-Vue-中使用-Pug-与-Less" class="headerlink" title="在 Vue 中使用 Pug 与 Less"></a>在 Vue 中使用 Pug 与 Less</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>　　<code>Vue</code> 中使用 <code>vue-loader</code> 根据 <code>lang</code> 属性自动判断所需要的 <code>loader</code>，所以不用额外配置 <code>Loader</code>，但是需要手动安装相关依赖：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i pug -D</span><br><span class="line">npm i less-loader -D</span><br></pre></td></tr></table></figure></p>
<p>还是相当方便的，不用手动修改 <code>webpack</code> 的配置文件添加 <code>loader</code> 就可以使用了</p>
<blockquote>
<p>使用 <code>pug</code> 还是 <code>pug-loader</code>？<code>sass</code> 两种语法的 <code>loader</code> 如何设置？<br>— 请参考 <a href="https://vue-loader.vuejs.org/zh-cn/configurations/pre-processors.html" target="_blank" rel="noopener">预处理器 · vue-loader</a></p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xxx.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.action</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#ddd</span>;</span></span><br><span class="line">      ul &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        li &#123;</span><br><span class="line">          float: left;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">lang</span>=<span class="string">"pug"</span>&gt;</span></span><br><span class="line">  .action(v-if='hasRight')</span><br><span class="line">    ul</span><br><span class="line">      li 编辑</span><br><span class="line">      li 删除</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data () &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        hasRight: <span class="literal">true</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="定义全局函数或变量"><a href="#定义全局函数或变量" class="headerlink" title="定义全局函数或变量"></a>定义全局函数或变量</h3><p>　　许多时候我们需要定义一些全局函数或变量，来处理一些频繁的操作（这里拿 <code>AJAX</code> 的异常处理举例说明）。但是在 <code>Vue</code> 中，每一个单文件组件都有一个独立的上下文（<code>this</code>）。通常在异常处理中，需要在视图上有所体现，这个时候我们就需要访问 <code>this</code> 对象，但是全局函数的上下文通常是 <code>window</code>，这时候就需要一些特殊处理了。</p>
<h4 id="简单粗暴型"><a href="#简单粗暴型" class="headerlink" title="简单粗暴型"></a>简单粗暴型</h4><p>　　最简单的方法就是直接在 <code>window</code> 对象上定义一个全局方法，在组件内使用的时候用 <code>bind</code>、<code>call</code> 或 <code>apply</code> 来改变上下文。</p>
<p>　　定义一个全局异常处理方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// errHandler.js</span></span><br><span class="line"><span class="built_in">window</span>.errHandler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 不能使用箭头函数</span></span><br><span class="line">  <span class="keyword">if</span> (err.code &amp;&amp; err.code !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'err'</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　在入口文件中导入：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'errHandler.js'</span></span><br></pre></td></tr></table></figure></p>
<p>　　在组件中使用：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.errHandler = <span class="built_in">window</span>.errHandler.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  method: &#123;</span><br><span class="line">    getXXX () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$http.get(<span class="string">'xxx/xx'</span>).then(<span class="function">(<span class="params">&#123; body: result &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.code === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.errHandler(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).catch(<span class="keyword">this</span>.errHandler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="优雅安全型"><a href="#优雅安全型" class="headerlink" title="优雅安全型"></a>优雅安全型</h4><p>　　在大型多人协作的项目中，污染 <code>window</code> 对象还是不太妥当的。特别是一些比较有个人特色的全局方法（可能在你写的组件中几乎处处用到，但是对于其他人来说可能并不需要）。这时候推荐写一个模块，更优雅安全，也比较自然，唯一不足之处就是每个需要使用该函数或方法的组件都需要进行导入。</p>
<p>　　使用方法与前一种大同小异，就不多作介绍了。￣ω￣=</p>
<h3 id="Moment-JS-与-Webpack"><a href="#Moment-JS-与-Webpack" class="headerlink" title="Moment.JS 与 Webpack"></a>Moment.JS 与 Webpack</h3><p>　　在使用 <code>Moment.js</code> 遇到一些问题，发现最终打包的文件中将 <code>Moment.js</code> 的全部语言包都打包了，导致最终文件徒然增加 100+kB。查了一下，发现可能是 <code>webpack</code> 打包或是 <code>Moment.js</code> 资源引用问题（?），目前该问题还未被妥善处理，需要通过一些 <code>trick</code> 来解决这个问题。</p>
<p>　　在 <code>webpack</code> 的生产配置文件中的 <code>plugins</code> 字段中添加一个插件，使用内置的方法类 <a href="https://webpack.js.org/plugins/context-replacement-plugin/" target="_blank" rel="noopener">ContextReplacementPlugin</a> 过滤掉 <code>Moment.js</code> 中那些用不到的语言包：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build/webpack.prod.conf.js</span></span><br><span class="line"><span class="keyword">new</span> webpack.ContextReplacementPlugin(<span class="regexp">/moment[\\/]locale$/</span>, /^\.\/(zh-cn)$/)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>解决方案采自 <a href="https://github.com/webpack/webpack/issues/3128#issuecomment-291790964" target="_blank" rel="noopener">oleg-nogin@webpack/webpack#3128</a>。<br>问题讨论详见 GitHub Issue: <a href="https://github.com/moment/moment/issues/2373" target="_blank" rel="noopener">moment/moment#2373</a>、<a href="https://github.com/webpack/webpack/issues/3128" target="_blank" rel="noopener">webpack/webpack#3128</a>。</p>
</blockquote>
<h3 id="自定义路径别名"><a href="#自定义路径别名" class="headerlink" title="自定义路径别名"></a>自定义路径别名</h3><p>　　可能有些人注意到了，在 <code>vue-cli</code> 生成的模板中在导入组件时使用了这样的语法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'@/components/Index'</span></span><br></pre></td></tr></table></figure></p>
<p>　　这个 <code>@</code> 是什么东西？后来改配置文件的时候发现这个是 <code>webpack</code> 的配置选项之一：路径别名。</p>
<p>　　我们也可以在基础配置文件中添加自己的路径别名，比如下面这个就把 <code>~</code> 设置为路径 <code>src/components</code> 的别名：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build/webpack.base.js</span></span><br><span class="line">&#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">      <span class="string">'~'</span>: resolve(<span class="string">'src/components'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　然后我们导入组件的时候就可以这样写：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import YourComponent from 'YourComponent'</span></span><br><span class="line"><span class="comment">// import YourComponent from './YourComponent'</span></span><br><span class="line"><span class="comment">// import YourComponent from '../YourComponent'</span></span><br><span class="line"><span class="comment">// import YourComponent from '/src/components/YourComponent'</span></span><br><span class="line"><span class="keyword">import</span> YourComponent <span class="keyword">from</span> <span class="string">'~/YourComponent'</span></span><br></pre></td></tr></table></figure></p>
<p>　　既解决了路径过长的麻烦，又解决了相对路径的烦恼，方便很多吧！ヾ(ﾟ∀ﾟゞ)</p>
<h3 id="CSS-作用域与模块"><a href="#CSS-作用域与模块" class="headerlink" title="CSS 作用域与模块"></a>CSS 作用域与模块</h3><h4 id="组件内样式"><a href="#组件内样式" class="headerlink" title="组件内样式"></a>组件内样式</h4><p>　　通常，组件中 <code>&lt;style&gt;&lt;/style&gt;</code> 标签里的样式是全局的，在使用第三方 UI 库（如：<code>Element</code>）时，全局样式很可能影响 UI 库的样式。</p>
<p>　　我们可以通过添加 <code>scoped</code> 属性来使 <code>style</code> 中的样式只作用于当前组件：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="keyword">@import</span> <span class="string">'other.less'</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">font-size</span>: 1<span class="selector-class">.2rem</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在有 <code>scoped</code> 属性的 <code>style</code> 标签内导入其他样式，同样会受限于作用域，变为组件内样式。复用程度较高的样式不建议这样使用。</p>
<p>另，在组件内样式中应避免使用元素选择器，原因在于元素选择器与属性选择器组合时，性能会大大降低。</p>
<p>— 两种组合选择器的测试：<a href="http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=.class%5Bclass%5E%3D%27class%27%5D&amp;body=background%3A+%23CFD&amp;ne=1000" target="_blank" rel="noopener">classes selector</a>，<a href="http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=a%5Bclass%5E%3D%27class%27%5D&amp;body=background%3A+%23CFD&amp;ne=1000" target="_blank" rel="noopener">elements selector</a></p>
</blockquote>
<h4 id="导入样式"><a href="#导入样式" class="headerlink" title="导入样式"></a>导入样式</h4><p>　　相对于 <code>style</code> 使用 <code>scoped</code> 属性时的组件内样式，有时候我们也需要添加一些全局样式。当然我们可以用没有 <code>scoped</code> 属性的 <code>style</code> 来写全局样式。</p>
<p>　　但是相比较，更推荐下面这种写法：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单独的全局样式文件 */</span></span><br><span class="line"><span class="comment">/* style-global.less */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.4rem</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　然后在入口文件中导入全局样式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'style-global.less'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="获取表单控件值"><a href="#获取表单控件值" class="headerlink" title="获取表单控件值"></a>获取表单控件值</h3><p>　　通常我们可以直接使用 <code>v-model</code> 将表单控件与数据进行绑定，但是有时候我们也会需要在用户输入的时候获取当前值（比如：实时验证当前输入控件内容的有效性）。</p>
<p>　　这时我们可以使用 <code>@input</code> 或 <code>@change</code> 事件绑定我们自己的处理函数，并传入 <code>$event</code> 对象以获取当前控件的输入值：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> @<span class="attr">change</span>=<span class="string">'change($event)'</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">change (e) &#123;</span><br><span class="line">  <span class="keyword">let</span> curVal = e.target.value</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/^\d+$/</span>.test(curVal)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.num = +curVal</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'%s is not a number!'</span>, curVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，如果 UI 框架采用 <code>Element</code> 会更简单，它的事件回调会直接传入当前值。</p>
</blockquote>
<h3 id="v-for-的使用-tips"><a href="#v-for-的使用-tips" class="headerlink" title="v-for 的使用 tips"></a>v-for 的使用 tips</h3><p>　　<code>v-for</code> 指令很强大，它不仅可以用来遍历数组、对象，甚至可以遍历一个数字或字符串。</p>
<p>　　基本语法就不讲了，这里讲个小 tips：</p>
<h4 id="索引值"><a href="#索引值" class="headerlink" title="索引值"></a>索引值</h4><p>　　在使用 <code>v-for</code> 根据对象或数组生成 <code>DOM</code> 时，有时候需要知道当前的索引。我们可以这样：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'(item, key) in items'</span> <span class="attr">:key</span>=<span class="string">'key'</span>&gt;</span> &#123;&#123; key &#125;&#125; - &#123;&#123; item &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　<strong>但是</strong>，在遍历数字的时候需要注意，数字的 <code>value</code> 是从 1 开始，而 <code>key</code> 是从 0 开始：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">'(v, k) in 3'</span> <span class="attr">:key</span>=<span class="string">'k'</span>&gt;</span> &#123;&#123; k &#125;&#125;-&#123;&#123; v &#125;&#125; </span><br><span class="line">  <span class="comment">&lt;!-- output to be 0-1, 1-2, 2-3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>2.2.0+</code> 的版本里，当在组件中使用 <code>v-for</code> 时，<code>key</code> 现在是必须的。</p>
</blockquote>
<h3 id="模板的唯一根节点"><a href="#模板的唯一根节点" class="headerlink" title="模板的唯一根节点"></a>模板的唯一根节点</h3><p>　　与 <code>JSX</code> 相同，组件中的模板只能有一个根节点，即下面这种写法是 <strong>错误</strong> 的：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span>Balabala...<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>　　我们需要用一个块级元素把他包裹起来：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span>Balabala...<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>原因参考：<a href="//blog.beard.ink/JavaScript/React-小记：组件开发注意事项/#唯一根节点">React-小记：组件开发注意事项#唯一根节点</a></p>
</blockquote>
<h3 id="项目路径配置"><a href="#项目路径配置" class="headerlink" title="项目路径配置"></a>项目路径配置</h3><p>　　由于 <code>vue-cli</code> 配置的项目提供了一个内置的静态服务器，在开发阶段基本不会有什么问题。但是，当我们把代码放到服务器上时，经常会遇到静态资源引用错误，导致界面一片空白的问题。</p>
<p>　　这是由于 <code>vue-cli</code> 默认配置的 <code>webpack</code> 是以站点根目录引用的文件，然而有时候我们可能需要把项目部署到子目录中。</p>
<p>　　我们可以通过 <code>config/index.js</code> 来修改文件引用的相对路径：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">build.assetsSubDirectory: <span class="string">'static'</span></span><br><span class="line">build.assetsPublicPath: <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">dev.assetsSubDirectory: <span class="string">'static'</span></span><br><span class="line">dev.assetsPublicPath: <span class="string">'/'</span></span><br></pre></td></tr></table></figure></p>
<p>　　我们可以看到导出对象中 <code>build</code> 与 <code>dev</code> 均有 <code>assetsSubDirectory</code>、<code>assetsPublicPath</code> 这两个属性。</p>
<p>　　其中 <strong>assetsSubDirectory</strong> 指静态资源文件夹，也就是打包后的　<code>js</code>、<code>css</code>、图片等文件所放置的文件夹，这个默认一般不会有问题。</p>
<p>　　<strong>assetsPublicPath</strong> 指静态资源的引用路径，默认配置为 <code>/</code>，即网站根目录，与 <strong>assetsSubDirectory</strong> 组合起来就是完整的静态资源引用路径 <code>/static</code>。</p>
<p>　　写到这里解决方法已经很明显了，只要把根目录改为相对目录就好了：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">build.assetsSubDirectory: <span class="string">'static'</span></span><br><span class="line">build.assetsPublicPath: <span class="string">'./'</span></span><br></pre></td></tr></table></figure></p>
<p>　　没错！就是一个 <code>.</code> 的问题。ㄟ( ▔, ▔ )ㄏ</p>
<h3 id="更小的-Polyfill-开销"><a href="#更小的-Polyfill-开销" class="headerlink" title="更小的 Polyfill 开销"></a>更小的 Polyfill 开销</h3><p>　　在引入 <code>Polyfill</code> 之后，可以在 <code>.babelrc</code> 文件中开启 <code>useBulitIns</code> 属性。启用该属性后，编译项目时会根据项目中新特性的使用情况将完整的 <code>polyfill</code> 拆分成独立的模块序列。<br>　　启用 <code>useBuiltIns</code> 属性：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123;</span><br><span class="line">      <span class="string">"modules"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">"useBuiltIns"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">"es2015"</span>,</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　安装后引入 <code>babel-polyfill</code>：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].find((<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
<p>  启用 <code>useBulitIns</code> 后自动拆分 <code>babel-polyfill</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/modules/es6.array.find'</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].find((<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>经测试最大减少了一半左右的 <code>polyfill</code> 体积<br>没深入研究哈，猜测可能加了 <code>core-js</code> 跟一些基础的 <code>polyfill</code></p>
</blockquote>
<h3 id="使用-ESnext-class-特性"><a href="#使用-ESnext-class-特性" class="headerlink" title="使用 ESnext class 特性"></a>使用 ESnext class 特性</h3><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>　　默认时，<code>Vue</code> 单文件组件使用一个对象来描述组件内部的实现：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line">  <span class="comment">// initialized data</span></span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      init: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// lifecycle hook</span></span><br><span class="line">  created () &#123;&#125;</span><br><span class="line">  mounted () &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure></p>
<p>　　我们可以通过安装一些依赖来支持最新的 <code>class</code> 写法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  init = <span class="literal">false</span>;</span><br><span class="line">  created () &#123;&#125;</span><br><span class="line">  mounted () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>不可否认，确实多些了一些代码哈，不过个人还是比较倾向新语法特性的写法的，毕竟标准即是灯塔<br>P.S 这里使用了还处于 <code>Stage 3</code> 的 <a href="https://github.com/tc39/proposal-class-fields#field-declarations" target="_blank" rel="noopener">Field declarations</a> 来声明组件的初始 <code>data</code></p>
</blockquote>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>　　下面来看看需要做哪些改动以支持使用 <code>class</code> 的写法：</p>
<ol>
<li>首先，最明显的就是我们需要 <code>vue-class-component</code> 这个依赖了。</li>
<li>然后，这个依赖需要 <code>babel</code> 的 <code>transform-decorators-legacy</code> 插件支持。</li>
<li>最后，如果你也想使用 Field declarations 字段声明写法，再添加一个 <code>transform-class-properties</code> 就好了。</li>
</ol>
<p>　　安装依赖：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i vue-class-component -D</span><br><span class="line">npm i babel-plugin-transform-decorators-legacy -D</span><br><span class="line">npm i babel-plugin-transform-class-properties -D</span><br></pre></td></tr></table></figure></p>
<p>　　配置 <code>babel</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-runtime"</span>,</span><br><span class="line">    <span class="string">"transform-decorators-legacy"</span>,</span><br><span class="line">    <span class="string">"transform-class-properties"</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong>：<code>transform-decorators-legacy</code> 需放在 <code>transform-class-properties</code> 之前</p>
</blockquote>
<h3 id="响应式数据失效"><a href="#响应式数据失效" class="headerlink" title="响应式数据失效"></a>响应式数据失效</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>　　由于 <code>Vue.js</code> 响应式数据依赖于<strong>对象方法</strong> <code>Object.defineProperty</code>。但很明显，数组这个特殊的“对象”并没有这个方法，自然也无法设置对象属性的 <code>descriptor</code>，从而也就没有 <code>getter()</code> 和 <code>setter()</code> 方法。所以在使用数组索引角标的形式更改元素数据时（<code>arr[index] = newVal</code>），视图往往无法响应式更新。<br>　　为解决这个问题，<code>Vue.js</code> 中提供了 <code>$set()</code> 方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.arr.$<span class="keyword">set</span>(0, 'newVal')</span><br><span class="line">// vm.arr[0] = 'newVal'</span><br></pre></td></tr></table></figure></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><blockquote>
<p>受现代 <code>JavaScript</code> 的限制（以及废弃 <code>Object.observe</code>），<code>Vue</code> <strong>不能检测到对象属性的添加或删除</strong>。由于 <code>Vue</code> 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 <code>Vue</code> 转换它，这样才能让它是响应的。<br>Ref: <a href="https://cn.vuejs.org/v2/guide/reactivity.html#变化检测问题" target="_blank" rel="noopener">深入响应式原理 - Vue.js</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 是响应的</span></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 是非响应的</span></span><br></pre></td></tr></table></figure>
<h3 id="静态类型检测"><a href="#静态类型检测" class="headerlink" title="静态类型检测"></a>静态类型检测</h3><p>　　推荐在开发较复杂的组件时使用 <code>props</code> 静态类型检测，提高组件的健壮性，多数情况下可以在转码阶段提前发现错误。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">prop: [</span><br><span class="line">  <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">'multiple'</span>,</span><br><span class="line">  <span class="string">'callback'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// after</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">      type: [ <span class="built_in">Number</span>, <span class="built_in">Array</span> ],</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    multiple: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    callback : <span class="built_in">Function</span>,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>　　使用处于 <code>Stage.3</code> 阶段的动态导入函数 <code>import()</code>，同时借助 <code>webpack</code> 的代码分割功能，在 <code>Vue.js</code> 中我们可以很轻松地实现一个异步组件。</p>
<h4 id="异步路由组件"><a href="#异步路由组件" class="headerlink" title="异步路由组件"></a>异步路由组件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./AsyncComponent'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="异步组件工厂"><a href="#异步组件工厂" class="headerlink" title="异步组件工厂"></a>异步组件工厂</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相比于异步路由组建，异步组件工厂一般适用于组件内进一步小颗粒度的拆分处理，如：大体量组件内初次加载时的非必要组件（组件内嵌套的弹窗组件或 <code>Popover</code> 组件等）。</p>
</blockquote>
<hr>
<p><strong>To be continue…</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 常用新特性讲解</title>
    <url>/JavaScript/ES6-%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p><strong>！干货长文预警！</strong></p>
</blockquote>
<p>上周在公司组织了 <code>ES6</code> 新特性的分享会，主要讲了工程化简介、<code>ES6</code> 的新特性与前端常用的几种构建工具的配合使用。<code>ES6</code> 这块主要讲了一些我们平时开发中经常会用到的新特性。在这里整理一下关于 <code>ES6</code> 的部分。<br><a id="more"></a><br>一共讲解了 8 个常用的 <code>ES6</code> 新特性，讲解过程也是由浅入深。废话不多说，下面进入正文。</p>
<hr>
<h3 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h3><h4 id="特性-amp-语法"><a href="#特性-amp-语法" class="headerlink" title="特性 &amp; 语法"></a>特性 &amp; 语法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimal</span>(<span class="params">num, fix</span>) </span>&#123;</span><br><span class="line">    fix = fix === <span class="keyword">void</span>(<span class="number">0</span>) ? <span class="number">2</span> : fix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> +num.toFixed(fix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decimal</span>(<span class="params">num, fix = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> +num.toFixed(fix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　首先，我们看一下之前我们是怎么写函数默认值的：我们通常会使用三元运算符来判断入参是否有值，然后决定是否使用默认值运行函数（如示例中 <code>fix = fix === void(0) ? 2 : fix</code>）</p>
<p>　　而在 <code>ES6</code> 中，我们可以直接在函数的显示入参中指定函数默认值（<code>function decimal(num, fix = 2){}</code>），很明显，这种写法更自然易懂，也更加方便，不过有一点需要注意：</p>
<ul>
<li>设定了默认值的入参，应该放在没有设置默认值的参数之后，也就是我们<strong>不应该</strong>这样写：<code>function decimal(fix = 2, num){}</code>，虽然通过变通手段也可以正常运行，但<strong>不符合规范</strong>。</li>
</ul>
<hr>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><h4 id="特性-amp-语法-1"><a href="#特性-amp-语法-1" class="headerlink" title="特性 &amp; 语法"></a>特性 &amp; 语法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="comment">// Before.1</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'simple'</span>;</span><br><span class="line"><span class="string">'This is a '</span> + type + <span class="string">' string join.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Before.2</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'multiline'</span>;</span><br><span class="line"><span class="string">'This \nis \na \n'</span> + type + <span class="string">'\nstring.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Before.3</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'pretty singleline'</span>;</span><br><span class="line"><span class="string">'This \</span></span><br><span class="line"><span class="string">is \</span></span><br><span class="line"><span class="string">a \</span></span><br><span class="line"><span class="string">'</span> + type + <span class="string">'\</span></span><br><span class="line"><span class="string">string.'</span></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="comment">// Before.4</span></span><br><span class="line"><span class="string">'This '</span> +</span><br><span class="line"><span class="string">'is'</span> +</span><br><span class="line"><span class="string">'a'</span> +</span><br><span class="line">type +</span><br><span class="line"><span class="string">'string.'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'singleline'</span>;</span><br><span class="line"><span class="string">`This is a <span class="subst">$&#123;type&#125;</span> string.`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'multiline'</span>;</span><br><span class="line"><span class="string">`This</span></span><br><span class="line"><span class="string">is</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;type&#125;</span></span></span><br><span class="line"><span class="string">string.`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'pretty singleline'</span>;</span><br><span class="line"><span class="string">`This \</span></span><br><span class="line"><span class="string">is \</span></span><br><span class="line"><span class="string">a \</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;type&#125;</span> \</span></span><br><span class="line"><span class="string">string.`</span></span><br></pre></td></tr></table></figure>
<p>　　我们之前在对字符串和变量进行拼接的时候，通常都是反复一段一段使用引号包裹的字符串，再反复使用加号进行拼接（Before.1）。多行字符串的时候我们还要写上蹩脚的 <code>\n</code> 来换行以得到一个多行的字符串（Before.2）。</p>
<p>　　在字符串过长的时候可能会使用 <code>\</code> 在编辑器中书写多行字符串来表示单行字符串，用来方便较长的字符串在编辑器中的阅读（Before.3），或者简单粗暴的反复引号加号这样多行拼接（Before.4）。</p>
<p>　　<code>ES6</code> 中我们可以使用反引号（`，位于 <code>TAB</code> 上方）来输入一段简单明了的多行字符串，还可以在字符串中通过 <code>${变量名}</code> 的形式方便地插入一个变量，是不是方便多了！</p>
<hr>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ,b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>　　数组解构，使用变量声明关键字声明一个形参数组（<code>[a, , b]</code>），等号后跟一个待解构目标数组（<code>[1, 2, 3]</code>），解构时可以通过留空的方式跳过数组中间的个别元素，但是在形参数组中<strong>必须留有相应空位</strong>才可以继续解构之后的元素，如果要跳过的元素处于<strong>数组末端</strong>，则在形参数组中<strong>可以不予留空</strong>。</p>
<h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;b, c&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>　　对象解构与数组解构大体相同，不过需要注意一点</p>
<ul>
<li>形参对象（<code>{b, c}</code>）的属性或方法名必须与待解构的目标对象中的属性或方法名完全相同才能解构到对应的属性或方法</li>
</ul>
<h4 id="对象匹配解构"><a href="#对象匹配解构" class="headerlink" title="对象匹配解构"></a>对象匹配解构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">a</span>: d, <span class="attr">b</span>: e, <span class="attr">c</span>: f&#125; = example();</span><br><span class="line"><span class="built_in">console</span>.log(d, e, f); <span class="comment">// =&gt; 1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>　　对象匹配解构是对象解构的一种延伸用法，我们可以在形参对象中使用<code>:</code>来更改解构后的变量名。</p>
<h4 id="函数入参解构"><a href="#函数入参解构" class="headerlink" title="函数入参解构"></a>函数入参解构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">&#123;param: value&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(example(&#123;<span class="attr">param</span>: <span class="number">5</span>&#125;)); <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>　　函数的入参解构也是对象解构的一种延伸用法，我们可以通过改写入参对象目标值为变量名的方式，在函数内部直接获取到入参对象中某个属性或方法的值。</p>
<h4 id="函数入参默认值解构"><a href="#函数入参默认值解构" class="headerlink" title="函数入参默认值解构"></a>函数入参默认值解构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">&#123;x, y, z = <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(example(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;));       <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="built_in">console</span>.log(example(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;)); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure>
<p>　　这是入参解构的另一种用法，我们可以在入参对象的形参属性或方法中使用等号的方式给入参对象的某些属性或方法设定默认值。</p>
<hr>
<h3 id="Let-amp-Const"><a href="#Let-amp-Const" class="headerlink" title="Let &amp; Const"></a>Let &amp; Const</h3><h4 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h4><ul>
<li><strong>无</strong>变量提升</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// =&gt; ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>　　使用 <code>var</code> 声明的变量会自动提升到当前作用域的顶部，如果声明位置与作用域顶部之间有另一个同名变量，很容易引起难以预知的错误。使用 <code>let</code> 声明的变量则不会进行变成提升，规避了这个隐患。</p>
<blockquote>
<p>注意：<code>var</code> 声明的变量提升后虽然在声明语句之前输出为 <code>undefined</code>，但这<strong>并不代表</strong> <code>num</code> 变量还没有被声明，此时 <code>num</code> 变量<strong>已经完成声明并分配了相应内存</strong>，只不过该变量<strong>目前的值</strong>为 <code>undefined</code>，并不是我们声明语句中赋的初始值 <code>1</code>。</p>
</blockquote>
<ul>
<li><strong>有</strong>块级作用域</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(num); <span class="comment">// =&gt; 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);     <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(num); <span class="comment">// =&gt; 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);     <span class="comment">// =&gt; ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>　　<code>let</code> 声明的变量只能在当前块级作用域中使用，最常见的应用大概就是 <code>for(let i = 0, i &lt; 10; i++) {}</code>，相信许多小伙伴在面试题中见过，哈哈。</p>
<ul>
<li><strong>禁止</strong>重复声明</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">var</span> dev = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> dev = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dev); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">let</span> dev = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> dev = <span class="literal">false</span>; <span class="comment">// =&gt; SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>　　<code>var</code> 声明的变量可以重复声明，而且不会有任何警告或者提示，就这样悄悄的覆盖了一个值，隐患如变量提升一样让人担忧。(￣┰￣*)</p>
<p>　　而 <code>let</code> 声明的变量如果进行重复声明，则会直接抛出一个<strong>语法错误</strong>（是的，就是直接明确地告诉你：你犯了一个相当低级的<strong>语法错误</strong>哦）</p>
<h4 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h4><ul>
<li>无变量提升</li>
<li>有块级作用域</li>
<li>禁止重复声明</li>
</ul>
<blockquote>
<p>前 3 点跟 <code>let</code> 一个套路，就不多说了</p>
</blockquote>
<ul>
<li>禁止重复赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEV = <span class="literal">true</span>;</span><br><span class="line">DEV = <span class="literal">false</span>; <span class="comment">// =&gt; TypeError</span></span><br></pre></td></tr></table></figure>
<p>　　基于静态常量的定义我们可以很明显知道，<code>const</code> 声明的常量一经声明便不能再更改其值，无需多说。</p>
<ul>
<li>必须附初始值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEV; <span class="comment">// =&gt; SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>　　也是基于定义，<code>const</code> 声明的常量既然一经声明便不能再更改其值，那声明的时候没有附初始值显然是不合理的，一个没有任何值的常量是没有意义的，浪费内存。</p>
<hr>
<h3 id="新增库函数"><a href="#新增库函数" class="headerlink" title="新增库函数"></a>新增库函数</h3><p>　　<code>ES6</code> 新增了许多（相当多）的库函数，这里只介绍一些比较常用的。</p>
<blockquote>
<p>题外话：多了解一下内建函数与方法有时候可以很方便高效地解决问题。有时候绞尽脑汁写好的一个算法，没准已经有内建函数实现了！而且内建函数经过四海八荒众神的考验，性能一定不错，哈哈。</p>
</blockquote>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">Infinity</span>); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'NaN'</span>);        <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
<p>　　首先是 ᶓ 这个常量属性，表示小数的极小值，主要用来判断浮点数计算是否精确，如果计算误差小于该阈值，则可以认为计算结果是正确的。</p>
<p>　　然后是 <code>isInteger()</code> 这个方法用来判断一个数是否为整数，返回布尔值。</p>
<p>　　最后是 <code>isNaN()</code> 用来判断入参是否为 <code>NaN</code>。是的，我们再也不用通过 <code>NaN</code> 不等于 <code>NaN</code> 才能确定一个 <code>NaN</code> 就是 <code>NaN</code> 这种反人类的逻辑来判断一个 <code>NaN</code> 值了！<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">NaN</span> !== <span class="literal">NaN</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Yes! This is actually the NaN!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　另外还有两个小改动：两个全局函数 <code>parseInt()</code> 与 <code>parseFloat()</code> 被移植到 <code>Number</code> 中，入参反参保持不变。这样所有数字处理相关的都在 <code>Number</code> 对象上嘞！规范多了。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'abcde'</span>.includes(<span class="string">'cd'</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="string">'abc'</span>.repeat(<span class="number">3</span>);        <span class="comment">// =&gt; 'abcabcabc'</span></span><br><span class="line"><span class="string">'abc'</span>.startsWith(<span class="string">'a'</span>);  <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="string">'abc'</span>.endsWith(<span class="string">'c'</span>);    <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>inclueds()</code> 方法用来判断一个字符串中是否存在指定字符串</li>
<li><code>repeat()</code> 方法用来重复一个字符串生成一个新的字符串</li>
<li><code>startsWith()</code> 方法用来判断一个字符串是否以指定字符串开头，可以传入一个整数作为第二个参数，用来设置查找的起点，默认为 <code>0</code>，即从字符串第一位开始查找</li>
<li><code>endsWith()</code> 与 <code>startsWith()</code> 方法相反</li>
</ul>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>)); <span class="comment">// =&gt; returns a real array.</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].fill(<span class="number">7</span>, <span class="number">1</span>); <span class="comment">// =&gt; [0, 7, 7]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x === <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// =&gt; 1</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].entries(); <span class="comment">// =&gt; Iterator [0: 'a'], [1: 'b'], [2: 'c']</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].keys();    <span class="comment">// =&gt; Iterator 0, 1, 2</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].values();  <span class="comment">// =&gt; Iterator 'a', 'b', 'c'</span></span><br><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>();        <span class="comment">// =&gt; []</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);       <span class="comment">// =&gt; [,,,]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// =&gt; [4, 5, 6]</span></span><br><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="built_in">Array</span>.of();         <span class="comment">// =&gt; []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">4</span>);        <span class="comment">// =&gt; [4]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// =&gt; [4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>　　首先是 <code>from()</code> 方法，该方法可以将一个类数组对象转换成一个<strong>真正的数组</strong>。还记得我们之前常写的 <code>Array.prototype.slice.call(arguments)</code> 吗？现在可以跟他说拜拜了~</p>
<p>　　之后的 <code>fill()</code> 方法，用来填充一个数组，第一个参数为将要被填充到数组中的值，可选第二个参数为填充起始索引（默认为 0），可选第三参数为填充终止索引（默认填充到数组末端）。</p>
<p>　　<code>findIndex()</code> 用来查找指定元素的索引值，入参为函数，函数形参跟 <code>map()</code> 方法一致，不多说。最终输出符合该条件的元素的索引值。</p>
<p>　　<code>entries()</code>、<code>keys()</code>、<code>values()</code> 三个方法各自返回对应键值对、键、值的遍历器，可供循环结构使用。</p>
<p>　　最后一个新增的 <code>of()</code> 方法主要是为了弥补 <code>Array</code> 当做构造函数使用时产生的怪异结果。</p>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> source = &#123;</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source); <span class="comment">// =&gt; &#123; a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>　　<code>assign()</code> 方法用于合并两个对象，不过需要注意的是这种合并是<strong>浅拷贝</strong>。可能看到这个方法我们还比较陌生，不过了解过 <code>jQuery</code> 源码的应该知道 <code>$.extend()</code> 这个方法，例如在下面这个粗糙的 <code>$.ajax()</code> 模型中的应用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> defaultOpts = &#123;</span><br><span class="line">        method: <span class="string">'GET'</span>,</span><br><span class="line">        <span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    opts = $.extend(defaultOpts, opts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　从这我们可以看到 <code>TC39</code> 也是在慢慢吸收百家所长，努力让 <code>JavaScript</code> 变得更好，更方便开发者的使用。</p>
<blockquote>
<p><code>Object</code> 新增的特性当然不止这一个 <code>assign()</code> 方法，一共增加了十多个新特性，特别是对属性或方法名字面量定义的增强方面，很值得一看，感兴趣的自行查找资料进行了解哈，印象会更深刻！</p>
</blockquote>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>　　<code>Math</code> 对象上同样增加了许多新特性，大部分都是数学计算方法，这里只介绍两个常用的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>);     <span class="comment">// =&gt; +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>);     <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-5</span>);    <span class="comment">// =&gt; -1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>);  <span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">-4.1</span>); <span class="comment">// =&gt; -4</span></span><br></pre></td></tr></table></figure></p>
<p>　　<code>sign()</code> 方法用来判断一个函数的正负，使用与对应返回值如上。</p>
<p>　　<code>trunc()</code> 用来取数值的整数部分，我们之前可能经常使用 <code>floor()</code> 方法进行取整操作，不过这个方法有一个问题就是：它本身是向下取整，当被取整值为正数的时候计算结果完全 OK，但是当被取整值为负数的时候：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="number">-4.1</span>); <span class="comment">// =&gt; -5</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>插播一个小 Tip：使用位操作符也可以很方便的进行取整操作，例如：<code>~~3.14</code> or <code>3.14 | 0</code>，也许这更加方便 : )</p>
</blockquote>
<hr>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>　　箭头函数无疑是 <code>ES6</code> 中一个相当重要的新特性。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>共享父级 <code>this</code> 对象</li>
<li>共享父级 <code>arguments</code></li>
<li>不能当做构造函数</li>
</ul>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="最简表达式"><a href="#最简表达式" class="headerlink" title="最简表达式"></a>最简表达式</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before</span></span><br><span class="line">arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// After</span></span><br><span class="line">arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">3</span>); <span class="comment">// =&gt; [4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>　　前后对比很容易理解，可以明显看出箭头函数极大地减少了代码量。</p>
<h5 id="完整语法"><a href="#完整语法" class="headerlink" title="完整语法"></a>完整语法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">arr.map(<span class="function">(<span class="params">v, k, thisArr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> thisArr.reverse()[k] * v;</span><br><span class="line">&#125;)  <span class="comment">// =&gt; [6, 10, 12, 12, 10, 6]</span></span><br></pre></td></tr></table></figure>
<p>　　一个简单的首尾相乘的算法，对比最简表达式我们可以发现，函数的前边都省略了 <code>function</code> 关键字，但是多个入参时需用括号包裹入参，单个入参是时可省略括号，入参写法保持一致。后面使用胖箭头 <code>=&gt;</code> 连接函数名与函数体，函数体的写法保持不变。</p>
<h5 id="函数上下文-this"><a href="#函数上下文-this" class="headerlink" title="函数上下文 this"></a>函数上下文 this</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    getMaxPow2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>,</span><br><span class="line">            getMax = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(&#123;&#125;, that.arr);</span><br><span class="line">            &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(getMax(), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    getMaxPow2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> getMax = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(&#123;&#125;, <span class="keyword">this</span>.arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(getMax(), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　注意看中第 5 行 <code>var that = this</code> 这里声明的一个<strong>临时变量 <code>that</code></strong>。在对象或者原型链中，我们以前经常会写这样一个临时变量，或 <code>that</code> 或 <code>_this</code>，诸如此类，以达到在一个函数内部访问到父级或者祖先级 <code>this</code> 对象的目的。</p>
<p>　　如今在箭头函数中，函数体内部没有自己的 <code>this</code>，默认在其内部调用 <code>this</code> 的时候，会自动查找其<strong>父级</strong>上下文的 <code>this</code> 对象（如果父级同样是箭头函数，则会按照作用域链继续向上查找），这无疑方便了许多，我们无需在多余地声明一个临时变量来做这件事了。</p>
<p>　　<strong>注意</strong>：</p>
<ol>
<li>某些情况下我们可能需要函数有自己的 <code>this</code>，例如 <code>DOM</code> 事件绑定时事件回调函数中，我们往往需要使用 <code>this</code> 来操作当前的 <code>DOM</code>，这时候就需要使用传统匿名函数而非箭头函数。</li>
<li>在严格模式下，如果箭头函数的上层函数均为箭头函数，那么 <code>this</code> 对象将不可用。</li>
</ol>
<blockquote>
<p>另，由于箭头函数没有自己的 <code>this</code> 对象，所以箭头函数不能当做构造函数。</p>
</blockquote>
<h5 id="父级函数-arguments"><a href="#父级函数-arguments" class="headerlink" title="父级函数 arguments"></a>父级函数 arguments</h5><p>　　我们知道在函数体中有 <code>arguments</code> 这样一个伪数组对象，该对象中包含该函数所有的入参（显示入参 + 隐式入参），当函数体中有另外一个函数，并且该函数为箭头函数时，该箭头函数的函数体中可以直接访问父级函数的 <code>arguments</code> 对象。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span></span><br><span class="line">            .prototype</span><br><span class="line">            .reduce</span><br><span class="line">            .call(<span class="built_in">arguments</span>, (pre, cur) =&gt; pre + cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> example();</span><br><span class="line">&#125;</span><br><span class="line">getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>由于箭头函数本身没有 <code>arguments</code> 对象，所以如果他的上层函数都是箭头函数的话，那么 <code>arguments</code> 对象将不可用。</p>
</blockquote>
<p>　　最后再巩固一下箭头函数的语法：</p>
<ol>
<li>当箭头函数入参只有一个时可以省略入参括号；</li>
<li>当入参多余一个或<strong>没有入参</strong>时必须写括号；</li>
<li>当函数体只有一个 <code>return</code> 语句时可以省略函数体的花括号与 <code>return</code> 关键字。</li>
</ol>
<hr>
<h3 id="类-amp-继承"><a href="#类-amp-继承" class="headerlink" title="类 &amp; 继承"></a>类 &amp; 继承</h3><p>　　类也是 <code>ES6</code> 一个不可忽视的新特性，虽然只是句法上的语法糖，但是相对于 <code>ES5</code>，学习 <code>ES6</code> 的类之后对原型链会有更加清晰的认识。</p>
<h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul>
<li>本质为对原型链的二次包装</li>
<li>类没有提升</li>
<li>不能使用字面量定义属性</li>
<li>动态继承类的构造方法中 <code>super</code> 优先 <code>this</code></li>
</ul>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 类不会被提升 */</span></span><br><span class="line"><span class="keyword">let</span> puppy = <span class="keyword">new</span> Animal(<span class="string">'puppy'</span>); <span class="comment">// =&gt; ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`The <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is sleeping...`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> type() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'This is an Animal class.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> puppy = <span class="keyword">new</span> Animal(<span class="string">'puppy'</span>);</span><br><span class="line"></span><br><span class="line">puppy.sleep();    <span class="comment">// =&gt; The puppy is sleeping...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化后无法访问静态方法 */</span></span><br><span class="line">puppy.type();     <span class="comment">// =&gt; TypeError</span></span><br><span class="line"></span><br><span class="line">Animal.type();    <span class="comment">// =&gt; This is an Animal class.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实例化前无法访问动态方法 */</span></span><br><span class="line">Animal.sleep();   <span class="comment">// =&gt; TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类不能重复定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>() </span>&#123;&#125; <span class="comment">// =&gt; SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>　　以上我们使用 <code>class</code> 关键字声明了一个名为 <code>Animal</code> 的类。</p>
<blockquote>
<p>虽然类的定义中并未要求类名的大小写，但鉴于代码规范，推荐类名的首字母大写。</p>
</blockquote>
<p>　　两点注意事项：</p>
<ol>
<li>在类的定义中有一个特殊方法 <code>constructor()</code>，该方法名固定，表示该类的构造函数（方法），在类的实例化过程中会被调用（<code>new Animal(&#39;puppy&#39;)</code>）；</li>
<li>类中无法像对象一样使用 <code>prop: value</code> 或者 <code>prop = value</code> 的形式定义一个类的属性，我们只能在类的构造方法或其他方法中使用 <code>this.prop = value</code> 的形式为类添加属性。</li>
</ol>
<p>　　最后对比一下我们之前是怎样写类的：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype = &#123;</span><br><span class="line">    sleep: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'The '</span> + <span class="keyword">this</span>.name + <span class="string">'is sleeping...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal.type = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'This is an Animal class.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>class</code> 关键字真真让这一切变得清晰易懂了~</p>
</blockquote>
<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="comment">/* 在 super 方法之前 this 不可用 */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// =&gt; ReferenceError</span></span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Right!</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    program() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I'm coding..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Save all files.'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Get into bed.'</span>);</span><br><span class="line">        <span class="keyword">super</span>.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coder = <span class="keyword">new</span> Programmer(<span class="string">'coder'</span>);</span><br><span class="line">coder.program(); <span class="comment">// =&gt; I'm coding...</span></span><br><span class="line">coder.sleep();   <span class="comment">// =&gt; Save all files. =&gt; Get into bed. =&gt; The coder is sleeping.</span></span><br></pre></td></tr></table></figure>
<p>　　这里我们使用 <code>class</code> 定义了一个类 <code>Programmer</code>，使用 <code>extends</code> 关键字让该类继承于另一个类 <code>Animal</code>。</p>
<p>　　如果子类有构造方法，那么在子类构造方法中使用 <code>this</code> 对象之前必须使用 <code>super()</code> 方法运行父类的构造方法以对父类进行初始化。</p>
<p>　　在子类方法中我们也可以使用 <code>super</code> 对象来调用父类上的方法。如示例代码中子类的 <code>sleep()</code> 方法：在这里我们重写了父类中的 <code>sleep()</code> 方法，添加了两条语句，并在方法末尾使用 <code>super</code> 对象调用了父类上的 <code>sleep()</code> 方法。</p>
<p>　　俗话讲：没有对比就没有伤害 (*゜ー゜*)，我们最后来看一下以前我们是怎么来写继承的：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Programmer</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Programmer.prototype = <span class="built_in">Object</span>.create(Animal.prototype, &#123;</span><br><span class="line">    program: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"I'm coding..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sleep: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Save all files.'</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Get into bed.'</span>);</span><br><span class="line">            Animal.prototype.sleep.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Programmer.prototype.constructor = Programmer;</span><br></pre></td></tr></table></figure></p>
<p>　　如果前文类的定义中的前后对比不足为奇，那么这个。。。</p>
<p>　　给你一个眼神，自己去体会 (⊙ˍ⊙)，一脸懵逼.jpg</p>
<hr>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><blockquote>
<p>啊哈，终于写到最后一部分了。</p>
</blockquote>
<p>　　模块系统是一切模块化的前提，在未推出 <code>ES6 Module</code> 标准之前，相信大伙儿已经被满世界飞的 <code>AMD</code>、<code>CMD</code>、<code>UMD</code>、<code>CommonJS</code> 等等百花齐放的模块化标准搞的晕头转向了吧。<strong>但是</strong>，现在 <code>TC39</code> 在 <code>ECMAScript2015(ES6)</code> 版本里<strong>终于推出了正式的模块化规范</strong>，前端模块系统的大一统时代已经到来了！</p>
<blockquote>
<p>OMG，这段话写的好燃 orz</p>
</blockquote>
<p>　　废话有点多。。。</p>
<p>　　下面咱们来了解一个这个模块系统的基本规范。</p>
<blockquote>
<p>为方便描述，下文中<strong>导出对象</strong>指一切可导出的内容（变量、函数、对象、类等），勿与对象（<code>Object</code>）混淆。<br><strong>导入对象</strong>同理。</p>
</blockquote>
<h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><ul>
<li>封闭的代码块<br>每个模块都有自己完全独立的代码块，跟作用域类似，但是更加封闭。</li>
<li>无限制导出导出<br>一个模块理论上可以导出无数个变量、函数、对象属性、对象方法，甚至一个完整的类。但是我们应该时刻牢记<strong>单一职责</strong>这一程序设计的基本原则，不要试图去开发一个臃肿的巨大的面面俱到的模块，合理控制代码的颗粒度也是开发可维护系统必不可少的一部分。</li>
<li>严格模式下运行<br>模块默认情况下在严格模式下运行（<code>&#39;use strict;&#39;</code>），这时候要注意一些取巧甚至有风险的写法应该避免，这也是保证代码健壮性的前提。</li>
</ul>
<h4 id="模块的定义与导出"><a href="#模块的定义与导出" class="headerlink" title="模块的定义与导出"></a>模块的定义与导出</h4><h5 id="内联导出"><a href="#内联导出" class="headerlink" title="内联导出"></a>内联导出</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DEV = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">expClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    DEV,</span><br><span class="line">    example,</span><br><span class="line">    expClass,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　使用 <code>export</code> 关键字，后面紧跟声明关键字（<code>let</code>、<code>function</code> 等）声明一个导出对象，这种声明并同时导出的导出方式称作<strong>内联导出</strong>。<br>　　未被导出的内容（变量、函数、类等）由于独立代码块的原因，将仅供模块内部使用（可类比成一种闭包）。</p>
<h5 id="对象导出"><a href="#对象导出" class="headerlink" title="对象导出"></a>对象导出</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module example.js</span></span><br><span class="line"><span class="keyword">const</span> DEV = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">expClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    DEV,</span><br><span class="line">    example,</span><br><span class="line">    expClass,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// module example.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;DEV, example, expClass, obj&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123;DEV, example <span class="keyword">as</span> exp, expClass, obj&#125;;</span><br></pre></td></tr></table></figure>
<p>　　相对于内联导出，上边的这种方式为<strong>对象导出</strong>。我们可以像写普通 <code>JS</code> 文件一样写主要的功能逻辑，最后通过 <code>export</code> 集中导出。</p>
<p>　　在导出时我们可以使用 <code>as</code> 关键字改变导出对象的名称。</p>
<h5 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;DEV, example <span class="keyword">as</span> exp, expClass, obj&#125;;</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> obj;</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> DEV = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>　　我们可以在 <code>export</code> 关键字后接 <code>default</code> 来设置模块的默认导出对象，需要注意的是：<strong>一个模块只能有一个默认导出</strong>。</p>
<p>　　先不多说，后面讲导入的时候再细讲相互之间的关联。</p>
<h4 id="模块的导入与使用"><a href="#模块的导入与使用" class="headerlink" title="模块的导入与使用"></a>模块的导入与使用</h4><h5 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h5><p>　　前文我们定义了一个名为 <code>example</code> 的模块，写在文件 <code>example.js</code>中，下面我们来导入并使用这个模块。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> example <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span><br><span class="line"><span class="comment">// OR </span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">default</span> <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span><br></pre></td></tr></table></figure></p>
<p>　　使用 <code>import</code> 关键字导入一个模块，上边这两种写法是等效的。默认导入对象既是模块默认导出对象，即对应模块定义中的 <code>export default</code> 所导出的内容。</p>
<p>　　此外我们还可以这样导入一个模块：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;DEV, example&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> exp <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> expMod, * <span class="keyword">as</span> expAll, DEV, example <span class="keyword">as</span> exp&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span><br></pre></td></tr></table></figure></p>
<p>　　这种导入方式对应模块定义中的 <code>export {DEV, example, expClass, obj}</code> 或 <code>export const DEV = true</code>。下面我们逐行分析：</p>
<p>　　第一行，我们使用对象导入的方式导入一个模块内容，可能有些人已经发现，这跟<strong>解构赋值</strong>很相似，但也有不同，下面会讲到。需要注意的是形参对象（<code>{DEV, example}</code>）与模块定义中导出的名称<strong>必须保持一致</strong>。</p>
<p>　　第二行，导入时可以使用通配符 <code>*</code> 配合 <code>as</code> 关键字一次性导出模块中所有内容，最终导入的内容放在 <code>exp</code> 对象中。</p>
<p>　　第三行，在使用对象导入来导入一个模块的指定内容时，也可以使用 <code>as</code> 关键字更改最终导入对象的名称，这里表现出<strong>与解构赋值的一个不同之处</strong>，忘记解构赋值的小伙伴可以翻翻前文对比一下哈~</p>
<p>　　最后，在导入一个模块后我们就可以直接使用模块的函数、变量、类等了，完整的代码示例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;DEV, example, expClass <span class="keyword">as</span> EC&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(DEV) &#123;</span><br><span class="line">    <span class="keyword">let</span> exp = <span class="keyword">new</span> EC();</span><br><span class="line">    <span class="comment">// anything you want...</span></span><br><span class="line">    example();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>　　好嘞！到这里，<code>ES6</code> 常用的 8 个新特性就讲完了，恭喜你耐心地看完了。当然，还有许多地方没有讲到，有时间的话会考虑继续写一些。</p>
<p>　　好嘞，就这样吧，希望对你有所帮助，拜拜~&lt;(*￣▽￣*)/。</p>
<blockquote>
<p>文中部分专业名词由于未找到合适译文，最后自行翻译，如有不妥，欢迎指正。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>ECMAScript2015</tag>
      </tags>
  </entry>
  <entry>
    <title>在 JavaScript 中函数为什么被称作一等公民？</title>
    <url>/JavaScript/%E5%9C%A8-JavaScript-%E4%B8%AD%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E7%A7%B0%E4%BD%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%9F/</url>
    <content><![CDATA[<p>如果读过<code>MDN</code>的话，应该会注意到<code>MDN</code>上对<code>JavaScript</code>的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="noopener">定义部分</a>是这样写的：</p>
<blockquote>
<p>JavaScript (JS) is a lightweight interpreted or JIT-compiled programming language with <strong>first-class functions</strong>. While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as node.js and Apache CouchDB. JavaScript is a prototype-based, multi-paradigm, dynamic language, supporting object-oriented, imperative, and declarative (e.g. functional programming) styles. Read more about JavaScript.</p>
</blockquote>
<p>开篇定义中便提到了函数优先（First-class Function），也即通常所说的<code>JavaScript</code>中的一等公民<code>Funciton</code>。<br>那问题来了：这个一等公民为什么会被称作一等公民呢？哪些特征让函数在<code>JavaScript</code>中成为了一等公民？<br><a id="more"></a></p>
<h3 id="其他语言中的函数"><a href="#其他语言中的函数" class="headerlink" title="其他语言中的函数"></a>其他语言中的函数</h3><p>在许多其他语言中（例如我们熟知的<code>C</code>、<code>C#</code>、<code>Java</code>等）中，只能用语言规定的关键字去声明一个函数，也必须使用声明的函数名调用，如果需要将函数本身进行传递、赋值等操作就只能借用函数指针（即引用地址）来操作，本质上还是操作原来的那个函数，也就是必须声明了一个函数，才能进行引用等操作。</p>
<h3 id="JavaScript-中的函数"><a href="#JavaScript-中的函数" class="headerlink" title="JavaScript 中的函数"></a>JavaScript 中的函数</h3><p>在<code>JavaScript</code>中，函数作为一等公民，他不仅拥有其他语言中函数的一切声明和调用方式，更可以像普通变量一样赋值、传递、反参。此外，在<code>JavaScript</code>中函数还可以通过<code>new</code>关键字拥有构造函数的功能。</p>
<hr>
<p>下面这些使用方法在<code>JavaScript</code>中很常见，但是，现在我们在使用时应该知道，正是因为在<code>JavaScript</code>中函数是一等公民，所以才有这些用法：</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">function [name]([param] [, param] [..., param]) &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<p>两种常见使用方式：</p>
<h4 id="自运行匿名函数"><a href="#自运行匿名函数" class="headerlink" title="自运行匿名函数"></a>自运行匿名函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// everything</span></span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<h4 id="匿名函数赋值"><a href="#匿名函数赋值" class="headerlink" title="匿名函数赋值"></a>匿名函数赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h3><h4 id="普通嵌套"><a href="#普通嵌套" class="headerlink" title="普通嵌套"></a>普通嵌套</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数 a 中声明一个函数 b</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// =&gt; 1 =&gt; 2</span></span><br></pre></td></tr></table></figure>
<h4 id="匿名嵌套"><a href="#匿名嵌套" class="headerlink" title="匿名嵌套"></a>匿名嵌套</h4><p>匿名嵌套主要用于防止全局变量污染<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    a(); <span class="comment">// =&gt; 1</span></span><br><span class="line">&#125;())</span><br><span class="line">a(); <span class="comment">// =&gt; ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>如果函数作为参数或返回值使用时，就称为<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">高阶函数</a>。</p>
<h4 id="函数传递"><a href="#函数传递" class="headerlink" title="函数传递"></a>函数传递</h4><p>将一个函数作为另一函数的参数进行传递<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个函数 a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明一个带参函数 b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行作为参数传递进来的函数</span></span><br><span class="line">    callback &amp;&amp; callback();</span><br><span class="line">&#125;</span><br><span class="line">b(a); <span class="comment">// =&gt; 2 =&gt; 1</span></span><br></pre></td></tr></table></figure></p>
<h4 id="反参函数"><a href="#反参函数" class="headerlink" title="反参函数"></a>反参函数</h4><p>将一个函数作为另一函数的反参输出<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">a()(); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">a.prototype.b = <span class="number">2</span>;</span><br><span class="line">a.prototype.c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">this</span>.d = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.d);</span><br><span class="line">    <span class="keyword">var</span> e = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> a().c(); <span class="comment">// =&gt; 1 =&gt; 2 =&gt; 3 =&gt; 4 =&gt; 5</span></span><br></pre></td></tr></table></figure>
<hr>
<p>最后附上<code>MDN</code>上对于<code>First-class Function</code>的解释：</p>
<blockquote>
<p>A programming language is said to have First-class functions when functions in that language are treated like any other variable. For example, in such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable.</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>React-小记：组件开发注意事项</title>
    <url>/JavaScript/React-%E5%B0%8F%E8%AE%B0%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>组件（<code>Component</code>）是<code>React</code>中非常重要的概念，<code>React</code>组件基于<code>jsx</code>语法开发，也就是把<code>HTML</code>写在<code>JS</code>中，刚开始接触的时候还是蛮抵触的，什么都搅在一起感觉挺乱的。不过真正开发起来会发现，只要颗粒度划分合理，一个完整的组件，所有内容都在一个文件中维护是多么方便！<br><a id="more"></a></p>
<blockquote>
<p>当然你也可以使用工厂方法进行开发，不过个人感觉很不直观且繁琐</p>
</blockquote>
<hr>
<h3 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h3><h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'./component/button.jsx'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Button name=<span class="string">'Click Me'</span> /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'index'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先组件<code>import</code>时首字母必须大写，然后通过<code>&lt;组件名 [参数1=值1, 参数2=值2...]/&gt;</code>引用，参数会传入组件的构造函数中<br>不能在组件<strong>引用</strong>上绑定事件，即<code>&lt;Button onClick={ clickHandler } /&gt;</code>，因为组件引用中除了组件名，其他部分都应该是组件入参。不过可以通过参数的形式将回调函数传到组件内部，然后进行绑定。</p>
</blockquote>
<h4 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'./component/botton.jsx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultBtn</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">name</span>=<span class="string">'Default'</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default DefaultBtn;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里定义了一个新组件<code>DefaultBtn</code>，该组件有引用了一个<code>Button</code>组件，并传入了参数<code>name</code>为<code>Default</code></p>
</blockquote>
<hr>
<h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>无状态的静态组件是最简单的，这里把常用的写法都写下了<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buttonClick(e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'button clicked!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">let</span> buttonStyle = &#123;</span><br><span class="line">            backgroundColor: <span class="string">'#03A9F4'</span>,</span><br><span class="line">            padding: <span class="string">'3px 20px'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">                &lt;button</span><br><span class="line">                    className = <span class="string">'buttonClass'</span></span><br><span class="line">                    onClick = &#123; <span class="keyword">this</span>.buttonClick.bind(<span class="keyword">this</span>) &#125;</span><br><span class="line">                    style = &#123; buttonStyle &#125;</span><br><span class="line">                    &gt;</span><br><span class="line">                        &#123; <span class="keyword">this</span>.props.name &#125;</span><br><span class="line">                &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Button;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="不痛不痒的提示"><a href="#不痛不痒的提示" class="headerlink" title="不痛不痒的提示"></a>不痛不痒的提示</h4><ol>
<li>组件名首字母必须大写</li>
<li>样式类的属性名是<code>className</code>不是<code>class</code></li>
<li>事件绑定通过<code>on</code>+<code>eventType</code>小驼峰写法<blockquote>
<p><code>JSX</code>描述<code>DOM</code>时，所有属性都采用小驼峰写法<br>这点很棒，一直对<code>DOM</code>中各种方法名时而大写时而小写感到不解，这里全规定为小驼峰写法，顿时顺眼多了</p>
</blockquote>
</li>
<li>元素内嵌样式使用对象来描述，样式属性名同样使用小驼峰写法，如<code>backgroundColor</code></li>
<li><code>JSX</code>中可以使用<code>{}</code>来写<code>JS</code>语句</li>
</ol>
<hr>
<p>几点踩坑点：</p>
<h3 id="React-引入名"><a href="#React-引入名" class="headerlink" title="React 引入名"></a>React 引入名</h3><p>在组件中如果引入<code>React</code>，则首字母须大写，也就是说引入<code>React</code>时不可以写成<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> react form <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在实际项目中，只要入口文件下所依赖的文件有一个进行了正确的<code>import</code>就可以嘞，毕竟<code>webpack</code>最后会把依赖去重。</p>
</blockquote>
<p>原因：在编译过程中，组件的许多部分都会转成对<code>React</code>中各个方法的引用，比如：<code>render()</code>的<code>return</code>被编译后，实质上返回的是<code>React.createElement()</code>，上文<code>return</code>语句编译后：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">'botton'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        className: <span class="string">'buttonClass'</span>,</span><br><span class="line">        onClick: <span class="keyword">this</span>.buttonClick.bind(<span class="keyword">this</span>)</span><br><span class="line">        style: buttonStyle,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.props.name</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="唯一根节点"><a href="#唯一根节点" class="headerlink" title="唯一根节点"></a>唯一根节点</h3><p>如果上文你想返回两个<code>button</code>，你可能会这样写：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Button1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">            &lt;button&gt;Button2&lt;<span class="regexp">/button&gt;);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>BUT</strong>，这是不行的，在<code>render()</code>中返回的<code>React</code>元素只能有一个根节点（原因看上文中的<code>React.createElement()</code>），也就是说，你只能这样写：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                 <span class="tag">&lt;<span class="name">button</span>&gt;</span>Button1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">                 <span class="tag">&lt;<span class="name">button</span>&gt;</span>Button2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>莫名其妙多了一层，我也很绝望啊 (。﹏。*)</p>
</blockquote>
<hr>
<h3 id="事件回调中的-this"><a href="#事件回调中的-this" class="headerlink" title="事件回调中的 this"></a>事件回调中的 this</h3><p>在<code>JSX</code>中给<code>DOM</code>绑定事件时，回调函数默认情况下无法访问当前组件，即回调函数中<code>this</code>不可用，一般情况下我们可以通过<code>bind()</code>来改变函数的上下文来使其可用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onClick = &#123; <span class="keyword">this</span>.buttonClick.bind(<span class="keyword">this</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>或者在组件的构造函数中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.buttonClick = <span class="keyword">this</span>.buttonClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//buttonClick(), render()...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者将事件回调放在一个上下文中：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick = &#123; () =&gt; <span class="keyword">this</span>.buttonClick() &#125; &gt;</span><br><span class="line">    ButtonName</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>比较倾向使用第一种方法，毕竟有时候访问<code>this</code>并不是必须的，随用随绑~</p>
</blockquote>
<hr>
<h3 id="事件回调处理"><a href="#事件回调处理" class="headerlink" title="事件回调处理"></a>事件回调处理</h3><p>在<code>React</code>事件回调函数中，可以显式传入一个合成事件（<code>SyntheticEvent</code>）的实例，他有如下属性与方法：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">boolean</span> bubbles</span><br><span class="line"><span class="built_in">boolean</span> cancelable</span><br><span class="line">DOMEventTarget currentTarget</span><br><span class="line"><span class="built_in">boolean</span> defaultPrevented</span><br><span class="line"><span class="built_in">number</span> eventPhase</span><br><span class="line"><span class="built_in">boolean</span> isTrusted</span><br><span class="line">DOMEvent nativeEvent</span><br><span class="line"><span class="built_in">void</span> preventDefault()</span><br><span class="line"><span class="built_in">boolean</span> isDefaultPrevented()</span><br><span class="line"><span class="built_in">void</span> stopPropagation()</span><br><span class="line"><span class="built_in">boolean</span> isPropagationStopped()</span><br><span class="line">DOMEventTarget target</span><br><span class="line"><span class="built_in">number</span> timeStamp</span><br><span class="line"><span class="built_in">string</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure></p>
<p>对于大多数常用事件的处理来说并不会感到有什么不同。不过在开发时还是需要注意，这个实例中封装了一些<code>React</code>特有的事件类型，可能与<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">传统事件</a>的属性与方法并不一一对应。</p>
<p>事件回调需要注意：</p>
<ol>
<li><h4 id="显式传入-Event"><a href="#显式传入-Event" class="headerlink" title="显式传入 Event"></a>显式传入 Event</h4><p>回调函数中须<strong>显式</strong>传入<code>event</code>参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buttonClick() &#123;</span><br><span class="line">    <span class="comment">// It doesn't work.</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(event.type); <span class="comment">// =&gt; 'react-click'</span></span><br><span class="line">&#125;</span><br><span class="line">buttonClick(event) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(event.type); <span class="comment">// =&gt; 'click'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="默认事件处理"><a href="#默认事件处理" class="headerlink" title="默认事件处理"></a>默认事件处理</h4><p>从 v0.14 开始，在事件回调函数中<code>return false;</code>将不再阻止事件的传递与元素的默认事件，需要在事件处理函数中手动写上<code>e.stopPropagation()</code>或<code>e.preventDefault()</code>。</p>
</li>
<li><h4 id="合成事件无法异步"><a href="#合成事件无法异步" class="headerlink" title="合成事件无法异步"></a>合成事件无法异步</h4>为了提高性能，合成事件（<code>SyntheticEvent</code>）是全局的，也就是说实质上只有一个合成事件，默认情况下当回调执行完毕后，所有属性都会被重置以便复用，回调函数中传入的<code>event</code>参数可以看做是他的一个状态，当回调执行完后就会被立刻重置，所以在异步函数中只能访问到被重置后的默认合成事件，而无法访问事件发生时的合成事件。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buttonClick(event) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type); <span class="comment">// =&gt; 'click'</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(event.type), <span class="number">0</span>); <span class="comment">// =&gt; null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>不过出于特殊考虑，<code>React</code>提供了<code>event.persist()</code>方法使当前事件不被重置，效果类似于深度拷贝了一个对象。<br>关于事件的其他细节可以参考<a href="https://facebook.github.io/react/docs/events.html" target="_blank" rel="noopener">SyntheticEvent - React</a></p>
</blockquote>
<p>先写这些吧，想起来再补充</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-小记：开发环境准备</title>
    <url>/JavaScript/React-%E5%B0%8F%E8%AE%B0%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>写下这个标题之后我愣了几分钟，突然发现无从下笔。随后想了想，就当是学习<code>React</code>过程中的随笔吧，写点简单的开发过程顺便记一些刚接触时踩到的坑。<br><a id="more"></a></p>
<hr>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="React-Developer-Tools"><a href="#React-Developer-Tools" class="headerlink" title="React Developer Tools"></a>React Developer Tools</h4><p>首先需要准备的就是<code>React</code>提供的<code>Chrome</code>拓展工具了，这个扩展在检测到开发状态的<code>React</code>程序时会在控制台添加一个<code>React</code>工具栏。在这里可以很方便的查看到组件间结构、属性、状态跟事件，可以很方便地进行调试：<br><img src="http://placehold.it/350x150" alt="React Developer Tools"><br>下载地址：<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">React Developer Tools</a></p>
<h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>由于<code>React</code>无法直接在浏览器环境中运行，需要使用<code>Webpack</code>进行通过<code>Babel</code>编译打包。</p>
<blockquote>
<p>当然你也可以直接引入<code>react.js</code>跟<code>react-dom.js</code>直接在浏览器中跑，不过很卡就是了。。。</p>
</blockquote>
<p>下面是<code>webpack</code>的低配：<br><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">var<span class="built_in"> path</span> = require(<span class="string">'path'</span>),</span><br><span class="line">   <span class="built_in"> root</span> =<span class="built_in"> path</span>.resolve(__dirname),</span><br><span class="line">    src  =<span class="built_in"> path</span>.resolve<span class="built_in">(root</span>, <span class="string">'js'</span>),</span><br><span class="line">    dist =<span class="built_in"> path</span>.resolve<span class="built_in">(root</span>, <span class="string">'../js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports = &#123;</span><br><span class="line">    entry:<span class="built_in"> path</span>.resolve(src, <span class="string">'index.jsx'</span>),</span><br><span class="line">    output: &#123;</span><br><span class="line">       <span class="built_in"> path</span>: dist,</span><br><span class="line">        filename: <span class="string">'index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">    module: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.jsx$/,</span><br><span class="line">                loader: <span class="string">'babel'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>简单说明：</p>
<ol>
<li><code>entry</code>：入口文件，<code>webpack</code>说白了就是从入口文件一层层地查找代码中使用了<code>require(xxx)</code>或<code>import x from x</code>语句，把所有依赖的文件全都写到一个文件里。对，就这么简单！</li>
<li><code>output</code>：指定最终打包好的文件输出到哪里，没什么可说的</li>
<li><code>devtool</code>：指定开发时生成<code>sourceMap</code>的格式，绝大多数直接用<code>cheap-module-eval-source-map</code>就OK，想深入了解的<a href="https://webpack.github.io/docs/configuration.html#devtool" target="_blank" rel="noopener">点这里</a></li>
<li><code>module.loaders</code>：一系列的加载器，<code>test</code>用来匹配<code>require(xxx)</code>中的<code>xxx</code>来确定是否用这个加载器处理所识别到的文件。<code>loader</code>用来指定加载器，这里指定的<code>babel</code>需要安装依赖<code>npm i -D babel-loader</code></li>
</ol>
</blockquote>
<h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p><code>Babel</code>的使用参考：<a href="http://blog.beard.ink/JavaScript/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%9A%E7%8E%B0%E5%9C%A8%E5%BC%80%E5%A7%8B%E7%94%A8ES6%E5%86%99%E4%BB%A3%E7%A0%81/">从零开始：现在开始用ES6写代码</a><br>这里的额外配置就是加一个<code>react</code>的转码包：</p>
<ol>
<li>安装预置转码包<code>npm i -D babel-preset-react</code></li>
<li>修改配置文件<code>.babelrc</code><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [<span class="string">"react"</span>, <span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="项目入口"><a href="#项目入口" class="headerlink" title="项目入口"></a>项目入口</h3><h4 id="访问入口-index-html"><a href="#访问入口-index-html" class="headerlink" title="访问入口 index.html"></a>访问入口 index.html</h4><p>首先我们要准备一个近乎空白的<code>HTML</code>文档：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>这个<code>HTML</code>文件<code>head</code>按需设置，或引入样式表，或设置<code>meta</code>，随你喜欢，<code>body</code>节点中<code>ID</code>为<code>root</code>的节点则是我们<code>react</code>所有<code>DOM</code>渲染的的目标节点，<br>一般情况下<strong>不要直接渲染到<code>body</code>节点中</strong>，虽然可以正常加载，但是控制台会弹出警告，这是因为许多工具或插件（譬如弹窗）也会渲染<code>DOM</code>到<code>body</code>节点中，这会影响<code>React</code>的正常运行</li>
<li>下面就是一个脚本引用，引用<code>webpack</code>配置中<code>output</code>所指的输出文件。</li>
</ol>
</blockquote>
<h4 id="逻辑入口-index-js"><a href="#逻辑入口-index-js" class="headerlink" title="逻辑入口 index.js"></a>逻辑入口 index.js</h4><p>这个入口其实就是<code>webpack</code>配置中的<code>entry</code>所指向的文件，也就是上文访问入口中引用的脚本文件，<code>webpack</code>将从这个文件开始查找依赖<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">'./component/index.jsx'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Index /&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'index'</span>));</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>引入三个依赖，其中前两个为<code>React</code>基础依赖，必须引入，最后一个为我们自己写的一个组件。<br><code>webpack</code>编译时将从这三条语句出发，按顺序查找依赖（按树查找，即：如果依赖中还有其他依赖，则一直查找下去，直到依赖树的末端为止），最后读取查找到的全部文件内容后，按照依赖顺序写入到当前文件中，最终输出到<code>output</code>中指定的位置</li>
<li><code>ReactDOM.render()</code>第一个参数为将要渲染的<code>React</code>元素，这里的<code>&lt;Index /&gt;</code>则是直接把第三行引入的组件直接放到这里进行渲染，第二个参数是指把这个组件渲染到页面的哪个<code>DOM</code>节点中。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>前端构建系统Gulp的使用与常用插件推荐</title>
    <url>/JavaScript/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9FGulp%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>随着<code>Web</code>前端发展，前端项目变得越来越复杂，随之而来的是各种方便的工具：打包工具、转码工具、JS 与<code>CSS</code>的合并压缩工具等等。这些工具极大的提高了我们前端的代码质量，但问题也随之而来：</p>
<p>这么多工具到底该怎么使用，难道一个个在各个工具中来回切换复制粘贴？或是在<code>CLI</code>里一条条地敲命里吗？<strong>敲完代码还要敲一堆的构建命令</strong>，说不准顺序搞错了还要功亏一篑<strong>重来一遍</strong>？纳尼？！！</p>
<p>于是构建系统应运而生，<code>Gulp</code>, <code>Grunt</code>, <code>Browserify</code>, etc. </p>
<p>使用构建系统的好处显而易见，就是一次配置，自动构建，省心省力妙不可言（怎么像广告词 orz）</p>
<p>此外因为配置文件的高度统一，这个配置文件几乎可以多个项目之间随便复制粘贴修修改改就可以<strong>重复使用</strong>！<br><a id="more"></a></p>
<p>不过可用的构建系统有很多，为避免引起圣战这里不做讨论_(:зゝ∠)_，我就用<code>Gulp</code>~</p>
<p>好嘞，废话说了这么多，下面进入正文：</p>
<h2 id="Node-与-Gulp-的安装"><a href="#Node-与-Gulp-的安装" class="headerlink" title="Node 与 Gulp 的安装"></a>Node 与 Gulp 的安装</h2><p>参考：<a href="http://blog.vsv.io/JavaScript/从零开始：现在开始用ES6写代码/" target="_blank" rel="noopener">从零开始：现在开始用ES6写代码</a>，使用<code>Babel</code>对<code>ES6</code>进行转码也就不在这里啰嗦嘞~</p>
<h2 id="为静态文件添加-MD5-指纹"><a href="#为静态文件添加-MD5-指纹" class="headerlink" title="为静态文件添加 MD5 指纹"></a>为静态文件添加 MD5 指纹</h2><p>使用<code>Gulp</code>自动对<code>HTML</code>中引用的静态文件添加<code>MD5</code>指纹戳，有效解决旧文件缓存，新文件无法更新的问题。</p>
<p>这部分有两种解决方案</p>
<h3 id="将MD5指纹写入文件名"><a href="#将MD5指纹写入文件名" class="headerlink" title="将MD5指纹写入文件名"></a>将<code>MD5</code>指纹写入文件名</h3><ul>
<li>效果：<code>&lt;script src=&#39;BearD01001-366dc531e1.min.js&#39;&gt;&lt;/script&gt;</code></li>
<li>优点：几乎可完美规避<strong>更新时短时间内客户端请求结果不一致</strong>的问题</li>
<li>缺点：每次修改文件都会产生一个新文件，易造成文件冗余</li>
<li>建议：推荐流量大、或没有绝对高峰期只有相对高峰期的大型<code>Web</code>系统使用</li>
<li>插件：<a href="https://www.npmjs.com/package/gulp-rev" target="_blank" rel="noopener">gulp-rev</a></li>
</ul>
<h3 id="写至文件引用URI的query中"><a href="#写至文件引用URI的query中" class="headerlink" title="写至文件引用URI的query中"></a>写至文件引用<code>URI</code>的<code>query</code>中</h3><ul>
<li>效果：<code>&lt;script src=&#39;BearD01001.min.js?rev=366dc531e1&#39;&gt;&lt;/script&gt;</code></li>
<li>优点：每次更新不会产生新文件，有效避免文件冗余</li>
<li>缺点：更新时短时间内，客户端请求到的静态文件可能不一致，<strong>造成非预期结果</strong></li>
<li>建议：推荐流量小、或可规避高峰期更新的<code>Web</code>系统使用</li>
<li>插件：<a href="https://www.npmjs.com/package/gulp-rev-append" target="_blank" rel="noopener">gulp-rev-append</a></li>
</ul>
<blockquote>
<p>两种解决方案优缺点已经说明，两个插件的使用方法也很简单，直接<code>pipe</code>到插件中就 OK ，这里不多废话嘞~</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> rev  = <span class="built_in">require</span>(<span class="string">'gulp-rev'</span>);</span><br><span class="line"><span class="comment">// var revAppend = require('gulp-rev-append');</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'*.html'</span>)</span><br><span class="line">        .pipe(rev())</span><br><span class="line">        <span class="comment">// .pipe(revAppend())</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="生成-Source-Map"><a href="#生成-Source-Map" class="headerlink" title="生成 Source Map"></a>生成 Source Map</h2><p>说到<code>Source Map</code>可能会有些小伙伴儿有些陌生，说白了这货就是在转码编译之前的文件与之后的文件生成一个字符对照表（深入了解参考 &gt;&gt; <a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="noopener">JavaScript Source Map 详解</a>）。</p>
<p>这样在浏览器开发者工具中，只要开启<code>sourcemaps</code>，调试过程中就可以在开发者工具中<strong>直接看到编译前的源文件，而不是编译后的文件</strong>。</p>
<p>如果出现问题也是直接报出问题出在源文件的哪行哪列，<code>Debug</code>起来相当方便！</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul>
<li><a href="https://www.npmjs.com/package/gulp-sourcemaps" target="_blank" rel="noopener">gulp-sourcemaps</a></li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>额(⊙_⊙)…上边好像说的差不多了</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>一般使用方法（<strong>不推荐</strong>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'javascript'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'src/**/*.js'</span>)</span><br><span class="line">        .pipe(sourcemaps.init())</span><br><span class="line">            .pipe(plugin1())</span><br><span class="line">            .pipe(plugin2())</span><br><span class="line">        .pipe(sourcemaps.write())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不推荐的原因是<code>gulp-sourcemaps</code>插件默认会将文件对照表信息<strong>全部写入转码编译后的文件末端</strong>。</p>
<p>一般这个对照表的信息量还是很大的，这对生产线上浏览器请求加载文件无疑是无用额外的开销，手动去除也是一件很低效费时的工作。</p>
</blockquote>
<p>指定输出路径（<strong>推荐</strong>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'javascript'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'src/**/*.js'</span>)</span><br><span class="line">        .pipe(sourcemaps.init())</span><br><span class="line">            .pipe(plugin1())</span><br><span class="line">            .pipe(plugin2())</span><br><span class="line">        .pipe(sourcemaps.write(<span class="string">'_srcmap'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里在<code>sourcemaps.write()</code>中传入了一个字符串<code>_srcmap</code>，用来指定<code>Source Map</code>即对照表的存储路径。</p>
<p>这样指定输出路径之后，文件编译转码完只会在最后一行只会写入对<code>Source Map</code>的文件引用，而<code>Source Map</code>对照表本身会被输出到指定的路径下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ sourceMappingURL=_srcmap/BearD01001.js.map</span></span><br></pre></td></tr></table></figure>
<p>这样在开启浏览器开发者工具后，开发者工具就会自动去匹配<code>Source Map</code>了。</p>
<p>而生产线上则完全不用担心</p>
<ol>
<li>谁会把<code>Source Map</code>文件放到生产线上？</li>
<li>即使真的放上了，如果开发者工具未打开，浏览器也不会去加载这个文件。</li>
</ol>
<h2 id="静态文件的合并与压缩"><a href="#静态文件的合并与压缩" class="headerlink" title="静态文件的合并与压缩"></a>静态文件的合并与压缩</h2><p><code>JS</code>、<code>CSS</code>文件的合并压缩应该是产品上线前最常见的需求了。</p>
<p>不再需要你在各个<code>JS</code>/<code>CSS</code>压缩合并的工具中切来切去，也不需要你在各个<code>IDE</code>或是<code>Editor</code>中复制粘贴手动拼接合并，这些<strong>繁琐低效</strong>的工作正是<code>Build System</code>要帮你解决的！</p>
<blockquote>
<p>接下来要介绍的这几个插件都非常常用，也有许多文章介绍了使用方法，就不多加说明了，动动手搜一搜吧！</p>
</blockquote>
<h3 id="JS-的压缩"><a href="#JS-的压缩" class="headerlink" title="JS 的压缩"></a>JS 的压缩</h3><h4 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h4><ul>
<li><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a></li>
</ul>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>使用<code>UglifyJS</code>压缩<code>JS</code>文件</p>
<h3 id="CSS-的压缩"><a href="#CSS-的压缩" class="headerlink" title="CSS 的压缩"></a>CSS 的压缩</h3><h4 id="插件-2"><a href="#插件-2" class="headerlink" title="插件"></a>插件</h4><ul>
<li><a href="https://www.npmjs.com/package/gulp-clean-css" target="_blank" rel="noopener">gulp-clean-css</a></li>
</ul>
<blockquote>
<p><strong>！注意！</strong> 搜索<code>CSS</code>压缩工具的时候极有可能搜到<code>gulp-minify-css</code>，<strong>该插件已被弃用</strong></p>
</blockquote>
<h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>使用<code>clean-css</code>压缩<code>CSS</code>文件</p>
<h3 id="JS-CSS-的合并"><a href="#JS-CSS-的合并" class="headerlink" title="JS / CSS 的合并"></a>JS / CSS 的合并</h3><blockquote>
<p><code>JS</code>或<code>CSS</code>文件的合并都是使用同一款插件<code>gulp-concat</code>。</p>
</blockquote>
<h4 id="插件-3"><a href="#插件-3" class="headerlink" title="插件"></a>插件</h4><ul>
<li><a href="https://www.npmjs.com/package/gulp-concat" target="_blank" rel="noopener">gulp-concat</a></li>
</ul>
<h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>合并<code>JS</code>或<code>CSS</code>文件</p>
<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>上边介绍了静态文件的合并与压缩，通常合并或压缩之后我们都会给文件重命名一下，压缩后习惯重命名为<code>FILENAME.min.js</code>，合并后习惯重命名为<code>all.js</code>、<code>main.css</code>等等，这时就需要重命名插件来帮帮嘞~</p>
<h3 id="插件-4"><a href="#插件-4" class="headerlink" title="插件"></a>插件</h3><ul>
<li><a href="https://www.npmjs.com/package/gulp-rename" target="_blank" rel="noopener">gulp-rename</a></li>
</ul>
<h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>文件重命名</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp   = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以这样简单粗暴的直接改名</span></span><br><span class="line">gulp.src(<span class="string">'BearD01001.txt'</span>)</span><br><span class="line">    .pipe(rename(<span class="string">'BearD01010.md'</span>))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./'</span>)); <span class="comment">// ./BearD01010.md</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以指定各种参数</span></span><br><span class="line">gulp.src(<span class="string">'BearD01001.txt'</span>)</span><br><span class="line">    .pipe(rename(&#123;</span><br><span class="line">        dirname:  <span class="string">'text/markdown'</span>,</span><br><span class="line">        basename: <span class="string">'myself'</span>,</span><br><span class="line">        prefix:   <span class="string">'introduce-'</span>,</span><br><span class="line">        suffix:   <span class="string">'-life'</span>,</span><br><span class="line">        extname:  <span class="string">'.md'</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./'</span>)); <span class="comment">// ./text/markdown/introduce-myself-life.md</span></span><br></pre></td></tr></table></figure>
<h2 id="自动合并雪碧图"><a href="#自动合并雪碧图" class="headerlink" title="自动合并雪碧图"></a>自动合并雪碧图</h2><h3 id="插件-5"><a href="#插件-5" class="headerlink" title="插件"></a>插件</h3><ul>
<li><a href="https://www.npmjs.com/package/gulp-spriter" target="_blank" rel="noopener">gulp-spriter</a></li>
</ul>
<h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>帮助前端工程师将<code>css</code>代码中的切片图片合并成雪碧图，支持<code>retina</code>图片。</p>
<blockquote>
<p>NPM上有详细的中文使用介绍，不多介绍，简单好用</p>
</blockquote>
<h2 id="小图标转码为内联-base64"><a href="#小图标转码为内联-base64" class="headerlink" title="小图标转码为内联 base64"></a>小图标转码为内联 base64</h2><h3 id="插件-6"><a href="#插件-6" class="headerlink" title="插件"></a>插件</h3><ul>
<li><a href="https://www.npmjs.com/package/gulp-base64" target="_blank" rel="noopener">gulp-base64</a></li>
</ul>
<h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>将<code>CSS</code>中引用的小图标转码为<code>base64</code>编码的<code>data URI</code>字符串，减少额外的<code>http</code>请求数。</p>
<h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><p>插件的使用非常简单，什么都不指定直接<code>pipe</code>到插件就OK了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础示例</span></span><br><span class="line">gulp.task(<span class="string">'build'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'./css/*.css'</span>)</span><br><span class="line">        .pipe(base64())</span><br><span class="line">        .pipe(concat(<span class="string">'main.css'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然也有简单但是十分好用的几个可选参数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">'build'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'./css/*.css'</span>)</span><br><span class="line">        .pipe(base64(&#123;</span><br><span class="line">            baseDir:        <span class="string">'public'</span>,</span><br><span class="line">            extensions:     [<span class="string">'svg'</span>, <span class="string">'png'</span>],</span><br><span class="line">            exclude:        [<span class="regexp">/\.server\.(com|net)\/dynamic\//</span>, <span class="string">'--live.jpg'</span>],</span><br><span class="line">            maxImageSize:   <span class="number">8</span>*<span class="number">1024</span>, <span class="comment">// bytes </span></span><br><span class="line">            debug:          <span class="literal">true</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(concat(<span class="string">'main.css'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>相信大家伙儿的英文都 OK，参数名称也很直观，就不加以说明啦<br>Tips：在<code>extensions</code>参数中可以使用正则（例如：/\.jpg#datauri$/i）匹配带有指定 hash 的引用文件，<br>这样在开发过程中就可以通过在文件末尾加上对应的<code>hash</code>（例如：<code>background-image: url(./images/icon.jpg#datauri);</code>）手动指定哪些文件转码成<code>data URI</code>嘞！</p>
</blockquote>
<h2 id="构建异常捕获"><a href="#构建异常捕获" class="headerlink" title="构建异常捕获"></a>构建异常捕获</h2><p>使用<code>Gulp</code>构建过程中一般会有<code>JS</code>、<code>Less</code>/<code>SCSS</code>编译转码的过程，这个过程是比较容易发生错误的，然鹅<code>Gulp</code>的默认做法是只要有插件抛出异常，那么整个<code>Gulp</code>的构建进程即停止运行。</p>
<p>也就是说即使出错后及时修正了错误并且保存了，还需要重新启动构建系统（即需要在<code>CLI</code>中重新输入<code>gulp [TASKNAME]</code>），这显然是很多余的一个步骤。</p>
<p>有没有什么方法在构建出错的时候不让构建进程<code>break down</code>呢？当然有！这就是<code>Gulp</code>官方推荐的构建插件之一<code>gulp-plumber</code>来做的事情，水管工，名字很贴切吧，哈哈~</p>
<p>还有一个问题，如果<code>Terminal</code>窗口没在屏幕的可视范围内，构建出错了我不知道怎么办？傻傻地等着以为构建会完成等了半天发现没有任何反应？调出终端才发现构建失败了？这里就用到了另一个辅助插件<code>gulp-util</code>，可以用它在构建出错的时候让电脑 <strong><em>哔 ~</em></strong> 的响一声，提示咱构建失败了赶紧<code>debug</code>！</p>
<h3 id="插件-7"><a href="#插件-7" class="headerlink" title="插件"></a>插件</h3><ol>
<li><a href="https://www.npmjs.com/package/gulp-plumber" target="_blank" rel="noopener">gulp-plumber</a></li>
<li><a href="https://www.npmjs.com/package/gulp-util" target="_blank" rel="noopener">gulp-util</a></li>
</ol>
<h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><ol>
<li><code>gulp-plumber</code>：构建异常捕获，防止构建进程崩掉</li>
<li><code>gulp-util</code>：这个插件其实很强大哈，集合了许多<code>Gulp</code>中常用的小工具，例如<code>log()</code>、<code>colors</code>等等，这里只用到了<code>beep()</code>&amp;<code>log</code>，就是让电脑 <strong><em>哔 ~</em></strong> 的响一声然后抛出异常，哈哈</li>
</ol>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp    = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    gutil   = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>),</span><br><span class="line">    babel   = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>),</span><br><span class="line">    concat  = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>),</span><br><span class="line">    plumber = <span class="built_in">require</span>(<span class="string">'gulp-plumber'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'build'</span>, () =&gt; &#123;</span><br><span class="line">    gulp.src(<span class="string">'./_src/js/*.js'</span>)</span><br><span class="line">        <span class="comment">// 最先 pipe 到 plumber 中，以便出现异常前准备捕获</span></span><br><span class="line">        .pipe(plumber(&#123; <span class="attr">errHandler</span>: <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            gutil.beep(); <span class="comment">// 哔~ 的响一声</span></span><br><span class="line">            gutil.log(e); <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;&#125;))</span><br><span class="line">        .pipe(babel())</span><br><span class="line">        .pipe(concat(<span class="string">'all.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public/js'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="使用-watch-插件提高构建效率"><a href="#使用-watch-插件提高构建效率" class="headerlink" title="使用 watch 插件提高构建效率"></a>使用 watch 插件提高构建效率</h2><p><code>gulp.src</code>这个方法相信大伙儿都特别熟悉了，传入<code>Glob</code>来匹配并读取文档流，但是这个方法的缺点也很明显，就是会读取全部匹配的文件（即使文件未作修改），这样导致的一个明显问题就是：</p>
<p><strong>随着项目的开发，文件越来越多，构建速度越来越慢。</strong></p>
<p>当然，我们可以使用<code>Gulp</code>内置的<code>watch</code>方法来规避这个问题，不过这个方法有一个小问题不知道大家有没有发现，就是它<strong>检测不到新建文件的事件</strong>，感觉蛮不合理的。所以现在一般使用<code>gulp-watch</code>这个插件，这个插件可以自定义触发事件，而且通过插件提供回调机制配合大家熟悉的<code>console</code>可以很方便的观察到构建流程。</p>
<h3 id="插件-8"><a href="#插件-8" class="headerlink" title="插件"></a>插件</h3><ul>
<li><a href="https://www.npmjs.com/package/gulp-watch" target="_blank" rel="noopener">gulp-watch</a></li>
</ul>
<h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>实时监测文件变化（可自定义触发事件与回调方法）</p>
<h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp    = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    watch   = <span class="built_in">require</span>(<span class="string">'gulp-watch'</span>),</span><br><span class="line">    gutil   = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>),</span><br><span class="line">    moment  = <span class="built_in">require</span>(<span class="string">'moment'</span>),</span><br><span class="line">    colors  = <span class="built_in">require</span>(<span class="string">'colors'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'js'</span>, () =&gt; &#123;</span><br><span class="line">    watch(<span class="string">'./_src/js/*.js'</span>, (vinyl) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123; moment().format(<span class="string">'HH:mm:ss'</span>).gray &#125;</span>] <span class="subst">$&#123; vinyl.basename.yellow &#125;</span> rebuilding.`</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .pipe(plugin1())</span><br><span class="line">        .pipe(plugin2())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public/js'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常的使用方法就是这样了，默认监测<code>[&#39;add&#39;, &#39;change&#39;, &#39;unlink&#39;]</code>通常是够用的，可以使用<code>options.events</code>来手动设置监测的事件类型。<br>回调函数会在每次监测到事件时触发，可以通过参数<code>vinyl</code>对象取得文件的详细信息。<br>前面的<code>watch</code>回调中实现了一个简单的构建流程监控，更完善的解决方案推荐使用 <a href="https://www.npmjs.com/package/gulp-notify" target="_blank" rel="noopener">gulp-notify</a> </p>
</blockquote>
<h2 id="其他提高构建体验的插件"><a href="#其他提高构建体验的插件" class="headerlink" title="其他提高构建体验的插件"></a>其他提高构建体验的插件</h2><p>上边大伙儿可能注意到了，使用了<code>gulp-moment</code>与<code>gulp-colors</code>，这两个插件无关项目，纯属为了更好的监控构建状态引入的两个插件，下面简单介绍一下</p>
<h3 id="插件-9"><a href="#插件-9" class="headerlink" title="插件"></a>插件</h3><ol>
<li><a href="https://www.npmjs.com/package/gulp-moment" target="_blank" rel="noopener">gulp-moment</a></li>
<li><a href="https://www.npmjs.com/package/gulp-colors" target="_blank" rel="noopener">gulp-colors</a></li>
</ol>
<h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><ol>
<li><code>gulp-moment</code>：相信不少小伙伴儿在<code>browser-side</code>用过<code>moment.js</code>这个工具，主要是进行时间方面的计算与格式化，<a href="http://momentjs.com/" target="_blank" rel="noopener">官网</a>有详细的介绍，使用起来很方便！</li>
<li><code>gulp-colors</code>：这个是用来设置<code>CLI</code>输出文字的颜色的，只要在任意字符串后面使用，就可以改变输出到终端的文字颜色、样式。</li>
</ol>
<h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><ol>
<li><code>gulp-moment</code>：<code>moment().format(&#39;HH:mm:ss&#39;)</code>格式化当前时间格式，其他参考<a href="http://momentjs.com/" target="_blank" rel="noopener">官网</a>文档；</li>
<li><code>gulp-colors</code>：<code>&#39;*.html&#39;.yellow</code>，任意字符串后面加上<code>.</code>+<code>COLOR</code>，即可改变颜色，<a href="https://github.com/Marak/colors.js" target="_blank" rel="noopener">项目主页</a>有多种配色与样式可供选择。</li>
</ol>
<hr>
<p>好嘞，终于写完了，上边就是使用<code>Gulp</code>进行前端构建的常用方法与插件了，希望对你有所帮助。</p>
<p>如有问题，欢迎提出指正</p>
<p>就酱~</p>
<p>-END</p>
<hr>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Babel</tag>
        <tag>Gulp</tag>
        <tag>SourceMap</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程：柯里化的变型应用</title>
    <url>/JavaScript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%8F%98%E5%9E%8B%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>函数柯里化不仅极大地提高了代码的可复用性与灵活性，而且降低了代码的耦合性，但是在生产环境中使用时发现了美中不足的一点，遂有此文，目的是改造柯里化函数结构，使之更方便使用、易于理解。<br><a id="more"></a></p>
<blockquote>
<p>为方便理解，本篇文章虚拟了一个简单的业务场景：更新指定栏目下指定节目的描述信息</p>
</blockquote>
<h1 id="普通的函数柯里化"><a href="#普通的函数柯里化" class="headerlink" title="普通的函数柯里化"></a>普通的函数柯里化</h1><p>首先，在变型前，一起看看大部分函数柯里化的实现与使用：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> updateProgramDesc = <span class="function"><span class="params">colunmID</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">programID</span> =&gt;</span> &#123;</span><br><span class="line">        desc =&gt; &#123;</span><br><span class="line">            <span class="comment">// do something...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法，更新 ID为10的栏目 下 ID为1000的节目 的描述信息为’description content.‘</span></span><br><span class="line">updateProgramDesc(<span class="number">10</span>)(<span class="number">1000</span>)(<span class="string">'description content.'</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="变型初衷"><a href="#变型初衷" class="headerlink" title="变型初衷"></a>变型初衷</h1><p>使用时很明显，每一层的函数在传参的时候很容易让人产生困惑：</p>
<ul>
<li>所使用的柯里化后的函数参数传到的哪一个层级？</li>
<li>该传入哪个参数了？</li>
<li>传入的这个参数是干什么的？</li>
</ul>
<p><strong>尤其</strong>在柯里化程度较高的情况下这种困扰尤为明显，使用时经常需要仔细观察上下文，甚至是去查看原函数来确定传参：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">func(<span class="name">param1</span>)(<span class="name">param2</span>)(<span class="name">param3</span>)(<span class="name">param4</span>)(<span class="name">param5</span>)(<span class="name">param6</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="柯里化的变型"><a href="#柯里化的变型" class="headerlink" title="柯里化的变型"></a>柯里化的变型</h1><p>出于以上初衷，对柯里化函数的结构做了一些调整，如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> updateColumn = <span class="function"><span class="params">colunmID</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        program(programID) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                desc(desc) &#123;</span><br><span class="line">                    <span class="comment">// do something...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>发现哪里不同了吗？</p>
</blockquote>
<p>下面是变型后的使用方法：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fully chain calls.</span></span><br><span class="line">updateColunm(10).<span class="keyword">program</span>(1000).<span class="keyword">desc</span>('description content.');</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial application invoke.</span></span><br><span class="line">let column = updateColunm(10);</span><br><span class="line">column</span><br><span class="line">    .<span class="keyword">program</span>(1001)</span><br><span class="line">    .<span class="keyword">desc</span>('<span class="keyword">update</span> the description of <span class="keyword">program</span> 1001 <span class="keyword">in</span> column 100.');</span><br><span class="line">column</span><br><span class="line">    .<span class="keyword">program</span>(1002)</span><br><span class="line">    .<span class="keyword">desc</span>('<span class="keyword">update</span> the description of <span class="keyword">program</span> 1002 <span class="keyword">in</span> column 100.');</span><br><span class="line"></span><br><span class="line">let <span class="keyword">program</span> = column.<span class="keyword">program</span>(1003);</span><br><span class="line"><span class="keyword">program</span>.<span class="keyword">desc</span>('<span class="keyword">update</span> the description of <span class="keyword">program</span> 1003 <span class="keyword">in</span> column 100.');</span><br><span class="line"><span class="keyword">program</span>.<span class="keyword">desc</span>('<span class="keyword">update</span> the new description of <span class="keyword">program</span> 1003 <span class="keyword">in</span> column 100.');</span><br></pre></td></tr></table></figure></p>
<h1 id="优点-amp-不足"><a href="#优点-amp-不足" class="headerlink" title="优点 &amp; 不足"></a>优点 &amp; 不足</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>通过<code>return</code> <code>object</code>代替<code>function</code>的方式，对象名可以非常恰当地对当前传参进行描述，使用时更清晰易懂，不易造成使用时确定传参困难、传参错误等情况。</p>
<blockquote>
<p>其实实现思想很简单吧~</p>
</blockquote>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>不过这种方法也有一个不足之处就是会增加少量代码与缩进，不过可以尝试使用<code>Promise</code>来实现，会更优雅自然~</p>
<h1 id="进一步可能"><a href="#进一步可能" class="headerlink" title="进一步可能"></a>进一步可能</h1><pre><code>updateDesc(desc).ofProgram(programID).inColumn(columnID);
</code></pre><p>发现了吗？可以写出更贴近自然语言的柯里化函数！<br>不过前文没有这么做，<strong>你知道是为什么吗？</strong></p>
<h1 id="灵感来源"><a href="#灵感来源" class="headerlink" title="灵感来源"></a>灵感来源</h1><p><code>jQuery</code>的链式函数调用~</p>
<p><em>参考文档：</em></p>
<blockquote>
<p><a href="https://www.sitepoint.com/currying-in-functional-javascript/" target="_blank" rel="noopener">A Beginner’s Guide to Currying in Functional JavaScript</a><br><a href="https://www.sitepoint.com/higher-order-functions-javascript/" target="_blank" rel="noopener">Higher-Order Functions in JavaScript</a><br><a href="http://www.cnblogs.com/pengchen/p/5434705.html" target="_blank" rel="noopener">JavaScript函数柯里化的一些思考</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>柯里化</tag>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title>前端必备技能——本地服务器的搭建&amp;配置</title>
    <url>/Server/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<img src="/Server/前端必备技能——本地服务器的搭建-配置/banner-frontend.png" class="full-image">
<p>虽说各种前端 <em>Build system</em> 均有各自的静态服务器插件提供使用，但是每次使用均需要反复启动并长时间占用一个 <em>Terminal</em> 窗口，并不是很方便。</p>
<p>对于需要长期开发和维护的项目，搭建一个持续稳定的本地服务是很有必要的。<br><a id="more"></a></p>
<p>本篇文章就简单介绍一下本地服务器的搭建与配置。</p>
<p>这里推荐使用集成环境 <strong>XAMPP</strong> ，选择它的主要原因是因为有比较友好的控制面板哈，此外后端开发我目前一直在使用 <em>PHP</em> 。<br>该集成环境 <em>Windows</em>、<em>OS X</em>、<em>Linux</em> 多平台持续更新哈~</p>
<p>下载完对应平台的安装包我们就开始吧！</p>
<ol>
<li><h3 id="XAMPP-安装组件的选择"><a href="#XAMPP-安装组件的选择" class="headerlink" title="XAMPP 安装组件的选择"></a>XAMPP 安装组件的选择</h3><p> 这里要简单讲一下 <em>Windows</em> 平台安装时的组件选择，<em>Linux</em> 用户可以跳过~，<em>OS X</em> 不太清楚哈</p>
<p> <img src="/Server/前端必备技能——本地服务器的搭建-配置/xampp-installation.png" alt="安装XAMPP"></p>
<ul>
<li><em>Apache</em> 服务器组件是必选的哈，不介绍了。由于偶尔会写一点后端代码，所以我这里把 <em>MySQL</em> 数据库也装上了，下边的 <em>PHPMyAdmin</em> 是用来管理数据库的，这个集成环境的 <em>PHP</em> 也是必选的哈，目前已经更新到7.0.9了，据说比5快一倍2333~</li>
<li><em>FileZilla</em> 是个 <em>FTP</em> 服务器、<em>Mercury</em> 是邮件服务器，含义简单明了，不过对于用来测试的本地服务器来说用处都不大。</li>
<li><em>Tomcat</em> 如果有喜欢使用 <em>JSP</em> 的后端同学可以把 <em>Tomcat</em> 也勾选上~</li>
<li><em>Perl</em> 通用脚本语言，这么火没用过肯定也听说过哈</li>
<li><em>Webbalizer</em> 日志分析系统</li>
<li><p><em>Fake Sendmail</em> 支持 <em>PHP</em> 发邮件的组件</p>
<p>组件选择完之后就可以一路 <em>Next</em> 下去嘞,直到安装完成</p>
<p><img src="/Server/前端必备技能——本地服务器的搭建-配置/xampp-interface.png" alt="XAMPP主界面"></p>
</li>
</ul>
</li>
<li><h3 id="修改服务器根目录指向"><a href="#修改服务器根目录指向" class="headerlink" title="修改服务器根目录指向"></a>修改服务器根目录指向</h3><p> 依次点击 <em>XAMPP</em> 控制面板上 <em>Apache</em> 所在行后面的 <em>Config</em> → <em>Apache (httpd.conf)</em>，打开 <em>Apache</em> 主配置文件 <em>httpd.conf</em>。</p>
<p> <img src="/Server/前端必备技能——本地服务器的搭建-配置/configure-web-root.png" alt="修改服务器根目录"></p>
<p> 这里主要讲一下本地服务器根目录的设置，将 <em>DocumentRoot</em> 与 <em>Directory</em> 的路径改为你常使用的工作目录，如这里改成‘<em>D:/DinoWeb</em>’。</p>
<p> 该目录将作为服务器的根目录使用。默认情况下，在浏览器中输入 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 或 <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a> 将直接访问到这个目录</p>
<p> <em>Directory</em> 中还有一些可选参数，简单介绍一下：</p>
<ul>
<li><p><em>Options</em>：可选指令集，多个值以空格分隔，值前可用 ‘+’/‘-‘ 表示从父目录继承指令后对所继承指令的增删，可选值‘<em>None</em>’、‘<em>All</em>’或以下组合：</p>
<ul>
<li><p><em>Indexes</em> - 无 <em>index.html/index.htm/index.php</em> 等文件时是否列出文件目录</p>
</li>
<li><p><em>FollowSymLinks</em> - 在该目录中，服务器将跟踪符号链接</p>
<blockquote>
<p>符号链接：<em>Linux</em> 系统中文件的快捷方式，在该目录中可以建立符号链接，以访问其他目录中的文件，配置此项以减少 <em>Apache</em> 调用其他系统函数检测符号链接。</p>
</blockquote>
</li>
<li><p><em>Includes</em> - 开启 <em>SSI</em>（即让 <em>html</em> 文件也支持相互 <em>include</em>）</p>
</li>
<li><p><em>ExecCGI</em> - 准许使用 <em>CGI</em></p>
</li>
<li><p><a href="http://httpd.apache.org/docs/2.4/mod/core.html#options" target="_blank" rel="noopener">更多…</a> （偷个懒，其他就不写了哈~）</p>
</li>
</ul>
</li>
<li><p><em>AllowOverride</em>：是否支持 <em>url rewrite</em>，值为 <em>All</em> 时则访问服务器时会读取目录下 <code>.htaccess</code> 文件以重写 <em>url</em>；</p>
<blockquote>
<p>粗暴点解释就是：浏览器访问 <em>a.html</em> 文件通过 <code>.htaccess</code> 处理之后实际上给你的是 <em>balabala.html</em> 的内容，但浏览器地址栏中显示的还是 <em>a.html</em>，目录重写同理。</p>
</blockquote>
</li>
<li><p><em>Require all granted/denied</em>：是否允许访问。</p>
</li>
</ul>
</li>
<li><h3 id="虚拟主机的配置"><a href="#虚拟主机的配置" class="headerlink" title="虚拟主机的配置"></a>虚拟主机的配置</h3><p> 为了更好地模拟真实的运行环境，一般推荐为每个项目配置一个独立的虚拟主机，而不是通过子目录的形式进行访问（例： <a href="http://localhost/myobject1" target="_blank" rel="noopener">http://localhost/myobject1</a> ），使用 <a href="http://myobject1.local" target="_blank" rel="noopener">http://myobject1.local</a> 进行访问更加优雅自然~</p>
<ol>
<li><h4 id="首先检查-httpd-conf"><a href="#首先检查-httpd-conf" class="headerlink" title="首先检查 httpd.conf"></a>首先检查 <code>httpd.conf</code></h4><p> 主配置文件中是否加载了虚拟主机配置文件，找到如下配置</p>
 <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Include</span> <span class="keyword">conf</span>/extra/httpd-vhosts.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<p> 若该行使用‘#’号被注释，记得去掉‘#’号以加载虚拟主机配置文件。</p>
</li>
<li><h4 id="然后配置httpd-vhosts-conf"><a href="#然后配置httpd-vhosts-conf" class="headerlink" title="然后配置httpd-vhosts.conf"></a>然后配置<code>httpd-vhosts.conf</code></h4><p> 依次点击 <em>XAMPP</em> 控制面板上 <em>Apache</em> 所在行后面的 <em>Config</em> → <em><browse> [Apache]</browse></em>，打开 <em>Apache</em> 所在文件夹，打开 <em>/conf/extra</em> 目录中的 <code>httpd-vhosts.conf</code> 虚拟主机配置文件。在文件末尾加上自己的虚拟主机配置：</p>
<p> <img src="/Server/前端必备技能——本地服务器的搭建-配置/virtual-host-config.png" alt="虚拟主机配置"></p>
<p> <strong>VirtualHost</strong> 指定了一个虚拟主机的 <em>IP</em> 地址与端口，端口默认为 <em>80</em>，<em>IP</em> 只要是内部回送地址就 <em>OK</em>，但不要用 <em>127.0.0.1</em>，这个是给根目录预留的哈，简单将一下其中的参数：</p>
<ul>
<li><p><em>Document</em> 与 <em>Directory</em> 和根目录配置一样，指虚拟主机所指向的目录。这里在 <em>Directory</em> 中重写了可选命令‘<em>-Indexes</em>’，代表目录中没有索引文件的时候禁止显示文件列表；</p>
</li>
<li><p><em>ServerName</em> - 虚拟主机名称，备注一样的存在~</p>
</li>
<li><p><em>DirectoryIndex</em> - 目录索引文件，就是首页入口 <em>index.html</em>、<em>default.html</em> 之类；</p>
</li>
<li><p><em>ErrorLog</em> - 异常日志</p>
</li>
<li><p><em>CustomLog</em> - 使用 <code>httpd.conf</code> 中默认声明的 <em>common</em> 日志格式来记录访问日志（说白了就是普通的访问日志不必记录的那么详细，简单点记就够用了）</p>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="设置本地-Hosts"><a href="#设置本地-Hosts" class="headerlink" title="设置本地 Hosts"></a>设置本地 Hosts</h3><p> 打开系统盘 <em>/Windows/System32/drivers/etc</em> 目录中的 <code>Hosts</code> 文件，在文件最末加上如下回送 <em>IP</em> 指向（类似小的 <em>DNS</em> 系统~）：</p>
 <figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.2</span> hello.local</span><br></pre></td></tr></table></figure>
<blockquote>
<p>127.0.0.2 - 上文配置虚拟主机时 <em>VirtualHost</em> 的回送 IP<br><strong>hello.local</strong> - 虚拟域名（类似于 <em>localhost</em>，名称随你喜欢想怎么起就怎么起~）</p>
</blockquote>
</li>
<li><h3 id="将-Apache-amp-MySQL-安装为系统服务并启动"><a href="#将-Apache-amp-MySQL-安装为系统服务并启动" class="headerlink" title="将 Apache&amp;MySQL 安装为系统服务并启动"></a>将 Apache&amp;MySQL 安装为系统服务并启动</h3><p> 所有的配置完成后就可以启动服务了，点击每行 <em>Action</em> 中的 <em>Start</em> 即可启动！~(≧▽≦)/~</p>
<blockquote>
<p>推荐将 <em>Apache</em> 与 <em>MySQL</em>（如果你需要的话）安装为系统服务，这样每次系统启动的时候就会自动加载主机服务，免去了手动启动的麻烦，依次点击每行最前面的大红叉即可安装为系统服务。</p>
</blockquote>
<p> <img src="/Server/前端必备技能——本地服务器的搭建-配置/install-apache-into-system-service.png" alt="将 Apache 安装为系统服务"></p>
</li>
<li><h3 id="赶紧写个栗子测试一下吧"><a href="#赶紧写个栗子测试一下吧" class="headerlink" title="赶紧写个栗子测试一下吧~"></a>赶紧写个栗子测试一下吧~</h3><ol>
<li><p>写个 <code>index.html</code> 放入虚拟主机所在目录（即上文中的 <em>D:/DinoWeb/HelloWorld</em>）<br> <img src="/Server/前端必备技能——本地服务器的搭建-配置/html-example.png" alt="HTML 栗子"></p>
</li>
<li><p>直接在浏览器地址栏中输入 <code>Hosts</code> 配置中所填的虚拟域名（即上文的 <a href="http://hello.local" target="_blank" rel="noopener">http://hello.local</a> ）即可直接访问！<br> <img src="/Server/前端必备技能——本地服务器的搭建-配置/run-in-browser.png" alt="访问你的本地虚拟主机"></p>
</li>
</ol>
</li>
</ol>
<p>现在你已经有了一个自己配置的本地服务器了！赶快试一下吧！！为你的每个项目配置一个独立的虚拟主机~</p>
<p>OVER.</p>
]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>XAMPP</tag>
        <tag>Server</tag>
        <tag>本地服务器</tag>
        <tag>虚拟主机</tag>
      </tags>
  </entry>
  <entry>
    <title>前端必备技能——切图：进阶篇</title>
    <url>/Photoshop/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E2%80%94%E2%80%94%E5%88%87%E5%9B%BE%EF%BC%9A%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
    <content><![CDATA[<img src="/Photoshop/前端必备技能——切图：进阶篇/banner-cut-slices.jpg" class="full-image">
<p>现代互联网对交互设计越来越重视，切图早已经不是简单的使用 <code>Photoshop</code> 的切片工具对 <em>JPG</em>、<em>PNG</em> 等文件进行切片操作了。UI 设计师给出的设计稿往往会是 <em>PSD</em> 分层文件，这种文件中包含了更加丰富的图层、通道、路径等信息，也为更优雅的前端交互奠定了基础。</p>
<p>（OS：这句话的 Bigger 我给满分o(￣▽￣)d~ 自我陶醉中…）<br><a id="more"></a></p>
<p>今天就来讲一下使用 <code>Photoshop</code> 对 <em>PSD</em> 分层设计稿进行切图的具体操作，老鸟也可以看一下，没准儿会有意外的收获哈~<br><strong>准备：</strong></p>
<ol>
<li><a href="http://pan.baidu.com/s/1i5hUECP" target="_blank" rel="noopener">Photoshop CC （提取码：gb8x）</a></li>
<li><a href="http://pan.baidu.com/s/1eSmKDvs" target="_blank" rel="noopener">PSD 设计稿（演示用稿：Navigation.psd）</a></li>
</ol>
<p><strong>开始：</strong></p>
<ol>
<li><h3 id="打开设计稿"><a href="#打开设计稿" class="headerlink" title="打开设计稿"></a>打开设计稿</h3><p> 简单介绍一下主界面<br> <img src="/Photoshop/前端必备技能——切图：进阶篇/photoshop-overview.jpg" alt="Photoshop主界面"></p>
<p> ① 为画布、② 为工具栏、③ 为图层操作面板</p>
<blockquote>
<p>加载 <em>PSD</em> 文件时可能会遇到嵌入的配置文件不匹配、字体丢失等问题，不用理会，直接按确定键即可。<br>Tips：如果③图层工作区默认没有显示，点击 菜单栏&gt;窗口&gt;图层 即可打开</p>
</blockquote>
</li>
<li><h3 id="分析设计稿"><a href="#分析设计稿" class="headerlink" title="分析设计稿"></a>分析设计稿</h3><p> 分析设计稿有哪些内容是需要进行切图保留的内容，主要内容考虑主要有以下几个部分：<br> ① <strong>图标</strong>（是否可以使用伪元素 <code>:before</code>、<code>:after</code> 实现，例如各种箭头图标）<br> ② <strong>背景</strong>（是否可以使用 <code>background</code> 实现）<br> ③ <strong>按钮</strong>（是否可以使用 <code>background</code>、<code>border-radius</code>、<code>:hover</code> 等实现交互效果）<br> ④ <strong>字体</strong>（是否被高频使用，是否需要做成单独的字体文件或做成切片）<br> ⑤ <strong>装饰性元素</strong>（是否可以使用伪元素 <code>:before</code>、<code>:after</code> 实现）<br> 现在我们来仔细分析一下这张设计稿：<br> <img src="/Photoshop/前端必备技能——切图：进阶篇/image-analyzing.jpg" alt="分析设计图"></p>
<ol>
<li><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><p> ② &amp; ④——这两部分都是图标，不同的是②这种简单的几何图标可以直接使用伪元素 <code>:before</code>、<code>:after</code> 来实现，不必做成图标切片；而④这种复杂的图标显然不能使用伪元素轻易画出来，这里鉴于图标数量较少可以直接做成单独切片或做成一张 <code>Sprite</code> 图。</p>
<blockquote>
<p>P.S.这种纯色图标如果页面中使用率较高，可以考虑使用 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> 图标库</p>
</blockquote>
</li>
<li><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p> ⑥ &amp; ⑧——⑧这类纯色/简单渐变的背景可以使用 <em>CSS</em> 直接实现；而⑥这类背景放大看可以发现他是有一定纹理的，这样的背景就只能进行切图了。</p>
</li>
<li><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><p> ①——这类按钮明显能使用 <em>CSS</em> 设计出来，用 <em>CSS3</em> 设置背景色的渐变打造光感、<code>border-radius</code> 设置按钮的圆角、<code>.active</code> &amp; <code>:hover</code> 状态类与伪类来实现交互效果。</p>
</li>
<li><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p> ③ &amp; ⑦——整体观察这个设计稿，大部分文字都是使用③的字体（高频使用），可以考虑把 UI 设计师使用的③字体做成 <code>.woff</code> 字体文件引入样式表中，或者直接使用通用的 <code>Arial/sans-serif</code> 字体（还原度会有所欠缺），至于⑦的字体，页面上使用率很低，只有页脚这一处用到，所以可以直接把⑦这里做成切片。</p>
</li>
<li><h4 id="装饰性元素"><a href="#装饰性元素" class="headerlink" title="装饰性元素"></a>装饰性元素</h4><p> ⑤——这种类似②这种简单的几何图标，但是仔细看有更丰富的光影与渐变效果，所以这里采用的是做成切片。</p>
<blockquote>
<p>开始切图之前的分析主要是考虑哪些部分可以使用 CSS 实现，哪些部分只能使用切片。这需要较好的 CSS 知识储备，但还好 CSS 的门槛不高，稍加学习即可掌握。</p>
</blockquote>
</li>
</ol>
</li>
<li><h3 id="开始切图"><a href="#开始切图" class="headerlink" title="开始切图"></a>开始切图</h3><ol>
<li><h4 id="图标-1"><a href="#图标-1" class="headerlink" title="图标"></a>图标</h4><p> <img src="/Photoshop/前端必备技能——切图：进阶篇/icon-slices.jpg" alt="图标"></p>
<p> 拉几条参考线后可以很明显发现这类图标的大小都极其接近，这类图标可以切成同一尺寸方便使用，这里以第一个统计图标为例：</p>
<blockquote>
<p>Tips：参考线可以通过在主画板顶部及左侧的标尺中通过拖拽添加 / 删除，如果没有打开标尺，按快捷键 Ctrl+R 即可显示标尺。</p>
</blockquote>
<p> <img src="/Photoshop/前端必备技能——切图：进阶篇/icon-slices-transform.jpg" alt="转换为只能对象"></p>
<p> 通过右下角图层面板找到这个图标的所在图层，右键单击该图层<strong>非缩略图区域</strong>，选择‘<strong>转换为智能对象</strong>’；然后双击该图层的缩略图，进入该图标的智能对象画板窗口：</p>
<p> <img src="/Photoshop/前端必备技能——切图：进阶篇/icon-slices-adjust.jpg" alt="图标调整"></p>
<p> 这时画布的大小正好是图标自身的大小（长宽像素不多不少）。</p>
<blockquote>
<p>Tips：通常在导出前我会调整一下图标画布的大小，一般是长宽各加几个像素，这样做的目的是虽然前面看起来这些图标大小都差不多，但是其实大小一般是有所差别的（特别是高度），如果直接按照没调整之前的大小导出，很有可能会导致用 CSS 定位的时候发现各个图标<strong>垂直方向无法对齐</strong>，从而还需要额外对每个图标单独进行对齐，这显然是不合理的。</p>
</blockquote>
<p> 按快捷键 Ctrl+Alt+C 调整画布大小：</p>
<p> <img src="/Photoshop/前端必备技能——切图：进阶篇/icon-slices-resize.jpg" alt="图标画布调整"></p>
<blockquote>
<p>最好调整所加的像素数为偶数，这样画布在拓展的时候才能保证图标仍在画布中心位置。</p>
</blockquote>
<p> 调整好画布大小后，按快捷键 Ctrl+Alt+Shift+S（这个快捷键有点多，是时候考验一下手指的灵活性了(o´・ェ・｀o)），然后会弹出介个‘存储为 Web 所用格式’的窗口：</p>
<p> <img src="/Photoshop/前端必备技能——切图：进阶篇/icon-slices-save.jpg" alt="存储为 Web 所有格式"></p>
<p> 两个圈起来的地方，一个是选择导出格式：需要保留透明度的选择PNG-24（PNG-8不支持半透明，这是为了照顾 IE6 的显示效果，现在谁还管 IE6，用 IE6 的人还想要什么优雅的交互体验，页面能显示出来主要内容就不错了，嫌弃脸.jpg &lt;_&lt;），不需要保留透明度的选择JPEG。</p>
<blockquote>
<p>选 PNG-24 记得勾选下方的‘交错’，选 JPEG 记得勾选‘连续’，这样在浏览器加载图片的时候会以模糊逐渐转为清晰的效果渐渐显示出来，浏览体验更好。</p>
</blockquote>
<p> 另一个是转换色彩空间：转换为 sRGB 可以在绝大部分浏览器中显示出你期望的颜色（涉及到图片的颜色配置管理，也是深坑，不多赘述）。<br> OK，其他选项都保持默认就好了，点击‘存储’，这样一个图标就‘切’好了！</p>
</li>
<li><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p> <img src="/Photoshop/前端必备技能——切图：进阶篇/background-slices.jpg" alt="背景"></p>
<p> 放大看我们可以看到这个背景的纹理是由有序重复的图案组成的，首先我们还是按照操作图标的步骤来：找到对应图层&gt;转换为智能对象&gt;进入编辑智能对象画板。然后使用裁剪工具（快捷键 C），配合 Ctrl+‘+’ 放大画板，仔细裁剪出重复的最小单元：</p>
<p> <img src="/Photoshop/前端必备技能——切图：进阶篇/background-slices-cut.jpg" alt="裁剪背景"></p>
<p> 最后同样 Ctrl+Alt+Shift+S 保存切片，这里由于该背景没有透明部分，所以保存格式选择 JPEG（即 .JPG 文件，相对于 PNG-24，对图片质量要求不高的情况下，JPEG 能获得更小的文件体积）。</p>
<p> 现在这个网格背景的切片就搞定了！配合 <code>background-repeat: repeat-x;</code> 即可实现网格的背景效果！</p>
<blockquote>
<p>Tips：这里如果想在使用背景切片之前确认一下最小重复单元的背景切片是否错位，可以点击 菜单栏&gt;定义图案 添加新图案，然后 Ctrl+N 新建一个与该背景切片高度相同，宽度较大一些的画板，然后 Shift+F5 打开填充对话框，‘内容&gt;使用’选择‘图案’，紧挨着下边的‘自定图案’选择刚刚添加的新图案，点击确认即可得到期望的背景，如果最小重复单元的切片出现错位等问题很容易发现，仔细重新裁剪一下就好啦~</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>好嘞，切图的进阶篇就写到这里了，只讲了图标跟背景，其他部分大同小异哈（才不是因为懒 (¯﹃¯)，感兴趣的同学可以<a href="http://pan.baidu.com/s/1eSmKDvs" target="_blank" rel="noopener">下载设计稿</a>练练手哈。</p>
<blockquote>
<p>写在最后：</p>
<blockquote>
<p>实际现如今对PSD文件进行的操作已经不是简单的切图了，</p>
<blockquote>
<p>但是鉴于最初确实是把整张JPG图片使用切片工具进行切成一个个小切片，</p>
<blockquote>
<p>所以切图这种叫法一直沿用至今。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>Photoshop</category>
      </categories>
      <tags>
        <tag>Photoshop</tag>
        <tag>切图</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始：现在开始用ES6写代码</title>
    <url>/JavaScript/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%9A%E7%8E%B0%E5%9C%A8%E5%BC%80%E5%A7%8B%E7%94%A8ES6%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p><code>ES6</code>（<code>ECMAScript6.0</code>）早在2015年便发布了第一个版本，所以又被称作<code>ECMAScript2015</code>。</p>
<p>作为已经正式发布的新版本，取代ES5是毋庸置疑的趋势，但鉴于浏览器的历史遗留问题，在生产线上我们还是需要一些工具来转换成<code>ES5</code>使其兼容旧版本的浏览器。<br><a id="more"></a><br>下面来介绍一下使用<code>Gulp</code>+<code>Babel</code>进行<code>ES6</code>开发环境的部署：</p>
<p>（操作很简单，写的比较详细所以字数比较多，别被吓退了哈，而且大部分配置都是一劳永逸，多个项目都可以通用，哈哈）</p>
<ol>
<li><h3 id="安装-NodeJS"><a href="#安装-NodeJS" class="headerlink" title="安装 NodeJS"></a>安装 NodeJS</h3><p> 既然使用<code>Gulp</code>跟<code>Babel</code>肯定少不了<code>NodeJS</code>，<code>NodeJS</code>各个平台均有对应的一键安装包，简单方便又省心！<br> <img src="/JavaScript/从零开始：现在开始用ES6写代码/nodejs-installation.jpg" alt="安装NodeJs"><br> 安装完成后打开命令行，分别输入</p>
 <figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure>
<p> 出现如下输出就代表安装成功了（这里我用的是<code>Git Bash</code>，推荐使用，安装<code>Git</code>自带）<br> <img src="/JavaScript/从零开始：现在开始用ES6写代码/nodejs-installed.jpg" alt="NodeJS安装成功"></p>
</li>
<li><h3 id="初始化NPM配置"><a href="#初始化NPM配置" class="headerlink" title="初始化NPM配置"></a>初始化NPM配置</h3><p> 在项目文件夹根目录，执行</p>
 <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> init</span><br></pre></td></tr></table></figure>
<p> <img src="/JavaScript/从零开始：现在开始用ES6写代码/npm-initialization.jpg" alt="初始化NPM"><br> 按照提示填好，除了<code>name</code>和<code>version</code>字段其他都是选填项，一路回车就OK了<br> 最后项目根目录会出现一个<code>package.json</code>的配置文件，多数情况不会手动去修改，安装依赖时<code>NodeJS</code>会自动读写这个配置文件。</p>
<blockquote>
<p>国内由于众所周知的原因NPM安装源访问的速度十分缓慢，建议使用如下命令更改为某宝的NPM镜像：<br><code>$ npm config set registry https://registry.npm.taobao.org/</code></p>
</blockquote>
</li>
<li><h3 id="安装-Gulp"><a href="#安装-Gulp" class="headerlink" title="安装 Gulp"></a>安装 Gulp</h3><ol>
<li><h4 id="首先-全局-安装Gulp"><a href="#首先-全局-安装Gulp" class="headerlink" title="首先 全局 安装Gulp"></a>首先 <strong>全局</strong> 安装<code>Gulp</code></h4> <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> -g gulp</span><br></pre></td></tr></table></figure>
<p> 安装过程可能出现一些警告，不用理他，最后执行</p>
 <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>gulp -v</span><br></pre></td></tr></table></figure>
<p> <img src="/JavaScript/从零开始：现在开始用ES6写代码/install-gulp.jpg" alt="安装Gulp"><br> 只要正确输出了版本号就OK了。</p>
</li>
<li><h4 id="然后在项目根目录安装-开发依赖："><a href="#然后在项目根目录安装-开发依赖：" class="headerlink" title="然后在项目根目录安装 开发依赖："></a>然后在项目根目录安装 <strong>开发依赖</strong>：</h4> <figure class="highlight q"><table><tr><td class="code"><pre><span class="line">$ npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> gulp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>许多小伙伴会疑惑这两种安装方法有什么差别，其实很简单，全局安装的一般是需要直接在命令行中使用的命令，比如这里的gulp：<br><code>$ gulp taskName</code><br>全局安装之后就可以直接在命令行中使用这样的命令来执行<code>Gulp</code>任务。<br>而在项目根目录安装的开发依赖则是在项目根目录中的 <code>node_modules</code> 目录中放入模块的文件，可以直接在项目中通过<code>require()</code>来引入的模块。</p>
</blockquote>
</li>
</ol>
</li>
<li><h3 id="安装-Gulp-amp-Babel-相关插件"><a href="#安装-Gulp-amp-Babel-相关插件" class="headerlink" title="安装 Gulp &amp; Babel 相关插件"></a>安装 Gulp &amp; Babel 相关插件</h3><ol>
<li><h4 id="首先安装-gulp-babel-："><a href="#首先安装-gulp-babel-：" class="headerlink" title="首先安装 gulp-babel ："></a>首先安装 <code>gulp-babel</code> ：</h4> <figure class="highlight q"><table><tr><td class="code"><pre><span class="line">$ npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> gulp-babel</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="安装转码包："><a href="#安装转码包：" class="headerlink" title="安装转码包："></a>安装转码包：</h4> <figure class="highlight q"><table><tr><td class="code"><pre><span class="line">$ npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-preset-latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我这里安装了最新版本的转码包，这个转码包支持<code>ES2017（Stage3）&amp;ES2016&amp;ES2015</code>语法的转换。<br>如果你只想使用正式推出的<code>ES6（ES2015）</code>，则可以仅安装<code>ES6</code>的转码包：<br><code>$ npm install --save-dev babel-preset-es2015</code></p>
</blockquote>
<p> Babel转码配置：</p>
 <figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">echo</span> '&#123; <span class="string">"presets"</span>: [<span class="string">"latest"</span>] &#125;' &gt; <span class="string">.babelrc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以手动在项目根目录创建 <code>.babelrc</code> 文件进行配置；<br>仅转换<code>ES6</code>的小伙伴将命令中的 <code>latest</code> 换成 <code>es2015</code> 就OK了。</p>
</blockquote>
</li>
<li><h4 id="安装-gulp-watch："><a href="#安装-gulp-watch：" class="headerlink" title="安装 gulp-watch："></a>安装 <code>gulp-watch</code>：</h4> <figure class="highlight q"><table><tr><td class="code"><pre><span class="line">$ npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> gulp-watch</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>gulp-watch</code> 用于实时监控文件变化实时编译文件，这样就不用每次写完代码再去手动运行<code>gulp</code>任务编译文件了，也是懒人必备！</p>
</blockquote>
</li>
</ol>
</li>
<li><h3 id="配置-Gulp"><a href="#配置-Gulp" class="headerlink" title="配置 Gulp"></a>配置 Gulp</h3><p> 终于到最后一步了，哈哈，具体配置如下图，写了比较详细的注释了：<br> <img src="/JavaScript/从零开始：现在开始用ES6写代码/configure-gulp.jpg" alt="配置Gulp"><br> 保存到项目根目录的 <code>gulpfile.js</code> 文件就好了。<br> 最后在项目根目录执行：</p>
 <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>gulp</span><br></pre></td></tr></table></figure>
<p> 即可运行默认任务（任务名为 <code>default</code>）</p>
</li>
</ol>
<p>赶快写个ES6语法试试吧~↖(^ω^)↗</p>
<p>初入前端，粗写几字，如有不足，还望指正，谢谢。</p>
<p>共勉。</p>
<p>-END</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>JS</tag>
        <tag>ECMAScript6</tag>
        <tag>ES2015</tag>
        <tag>Babel</tag>
        <tag>Gulp</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title>JS简单小巧的时间日期格式转换函数</title>
    <url>/JavaScript/JS%E7%AE%80%E5%8D%95%E5%B0%8F%E5%B7%A7%E7%9A%84%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>JS简单小巧的时间日期格式转换函数</strong></p>
<ol>
<li><h3 id="这是实现后的使用方法"><a href="#这是实现后的使用方法" class="headerlink" title="这是实现后的使用方法"></a>这是实现后的使用方法</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line"><span class="keyword">var</span> nowStr = now.format(<span class="string">'yyyy-MM-dd hh:mm:ss'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testDate = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span><br><span class="line"><span class="keyword">var</span> testStr = testDate.format(<span class="string">'YYYY年MM月dd日hh小时mm分ss秒'</span>); </span><br><span class="line">alert(testStr); </span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Date</span>().format(<span class="string">'yyyy年MM月dd日'</span>)); </span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Date</span>().format(<span class="string">'MM/dd/yyyy'</span>)); </span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Date</span>().format(<span class="string">'yyyyMMdd'</span>)); </span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Date</span>().format(<span class="string">'yyyy-MM-dd hh:mm:ss'</span>));</span><br></pre></td></tr></table></figure>
 <a id="more"></a>
</li>
<li><h3 id="实现方法：在Date原型上添加方法"><a href="#实现方法：在Date原型上添加方法" class="headerlink" title="实现方法：在Date原型上添加方法"></a>实现方法：在Date原型上添加方法</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.prototype.format = <span class="function"><span class="keyword">function</span>(<span class="params">format</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> o = &#123;</span><br><span class="line">        <span class="string">'M+'</span>: <span class="keyword">this</span>.getMonth() + <span class="number">1</span>,                      <span class="comment">//month</span></span><br><span class="line">        <span class="string">'d+'</span>: <span class="keyword">this</span>.getDate(),                           <span class="comment">//day</span></span><br><span class="line">        <span class="string">'h+'</span>: <span class="keyword">this</span>.getHours(),                          <span class="comment">//hour</span></span><br><span class="line">        <span class="string">'m+'</span>: <span class="keyword">this</span>.getMinutes(),                        <span class="comment">//minute</span></span><br><span class="line">        <span class="string">'s+'</span>: <span class="keyword">this</span>.getSeconds(),                        <span class="comment">//second</span></span><br><span class="line">        <span class="string">'q+'</span>: <span class="built_in">Math</span>.floor((<span class="keyword">this</span>.getMonth() + <span class="number">3</span>) / <span class="number">3</span>),    <span class="comment">//quarter</span></span><br><span class="line">        <span class="string">'S'</span>: <span class="keyword">this</span>.getMilliseconds()                     <span class="comment">//millisecond</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/(y+)/</span>.test(format)) &#123;</span><br><span class="line">        format = format.replace(</span><br><span class="line">            <span class="built_in">RegExp</span>.$<span class="number">1</span>,</span><br><span class="line">            (<span class="keyword">this</span>.getFullYear() + <span class="string">''</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'('</span> + k + <span class="string">')'</span>).test(format)) &#123;</span><br><span class="line">            format = format.replace(</span><br><span class="line">                <span class="built_in">RegExp</span>.$<span class="number">1</span>,</span><br><span class="line">                <span class="built_in">RegExp</span>.$<span class="number">1.</span>length == <span class="number">1</span> ?</span><br><span class="line">                    o[k]: (<span class="string">'00'</span> + o[k]).substr((<span class="string">''</span> + o[k]).length)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> format;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><em>(摘自网络，作者不详)</em></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS</tag>
        <tag>Date</tag>
        <tag>时间</tag>
        <tag>日期</tag>
        <tag>格式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>细数JavaScript中那些神乎其神的技巧</title>
    <url>/JavaScript/%E7%BB%86%E6%95%B0JavaScript%E4%B8%AD%E9%82%A3%E4%BA%9B%E7%A5%9E%E4%B9%8E%E5%85%B6%E7%A5%9E%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p><strong>闲来无事，整理一下JavaScript中那些神乎其神的技巧，假装大牛的样子</strong></p>
<h2 id="1-字符串转换为数字"><a href="#1-字符串转换为数字" class="headerlink" title="1. 字符串转换为数字"></a>1. 字符串转换为数字</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(+a);         <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> +a);  <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样可用于日期转换为数值：</span></span><br><span class="line"><span class="keyword">var</span> b = +<span class="keyword">new</span> <span class="built_in">Date</span>();     <span class="comment">// 1468545682168</span></span><br></pre></td></tr></table></figure>
<h2 id="2-数值向下取整"><a href="#2-数值向下取整" class="headerlink" title="2. 数值向下取整"></a>2. 数值向下取整</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ~~<span class="number">3.14</span>;   <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3.14</span>&gt;&gt;<span class="number">0</span>;  <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = <span class="number">3.14</span>|<span class="number">0</span>;   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="3-字符串转换为数值并取整"><a href="#3-字符串转换为数值并取整" class="headerlink" title="3. 字符串转换为数值并取整"></a>3. 字符串转换为数值并取整<a id="more"></a></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"3.14"</span>|<span class="number">0</span>;  <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"3.14"</span>^<span class="number">0</span>;  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>谢谢 @开始学习前端[kaishixuexiqianduan] 指正，<strong>该取整直接去除小数点后数字，仅对正数有效</strong></p>
</blockquote>
<h2 id="4-函数设置默认值"><a href="#4-函数设置默认值" class="headerlink" title="4. 函数设置默认值"></a>4. 函数设置默认值</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(arg)</span></span>&#123;</span><br><span class="line">    var <span class="built_in">arg</span> = <span class="built_in">arg</span> || <span class="string">"default"</span>; </span><br><span class="line">    // <span class="built_in">arg</span> 为 undefined, null, <span class="string">""</span>, <span class="number">0</span>, <span class="literal">false</span>, NaN 时最后都得到<span class="string">"default"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-变量值交换"><a href="#5-变量值交换" class="headerlink" title="5. 变量值交换"></a>5. 变量值交换</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">var a = 1,</span><br><span class="line"><span class="code">    b = 2;</span></span><br><span class="line">a = [<span class="string">b, b = a</span>][<span class="symbol">0</span>];</span><br><span class="line">console.log(a);  // 2</span><br><span class="line">console.log(b);  // 1</span><br></pre></td></tr></table></figure>
<h2 id="6-使用for-in遍历对象取到属性名与属性"><a href="#6-使用for-in遍历对象取到属性名与属性" class="headerlink" title="6. 使用for in遍历对象取到属性名与属性"></a>6. 使用<code>for in</code>遍历对象取到属性名与属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"obj."</span> + i + <span class="string">" = "</span> + obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: obj.a = 1</span></span><br><span class="line"><span class="comment">//         obj.b = 2</span></span><br></pre></td></tr></table></figure>
<h2 id="7-截断数组"><a href="#7-截断数组" class="headerlink" title="7. 截断数组"></a>7. 截断数组</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr</span> <span class="string">=</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">5</span><span class="string">,</span> <span class="number">6</span><span class="string">];</span></span><br><span class="line"><span class="string">arr.length</span> <span class="string">=</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line"><span class="string">console.log(arr);</span>  <span class="string">//</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<h2 id="8-提高遍历较大Enumerable数据的性能"><a href="#8-提高遍历较大Enumerable数据的性能" class="headerlink" title="8. 提高遍历较大Enumerable数据的性能"></a>8. 提高遍历较大Enumerable数据的性能</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, ...];</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">len</span> = arr.length;  <span class="comment">// 缓存arr.length</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可将缓存写在for的声明中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, <span class="built_in">len</span> = a.length; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者（！注意：若数组中键值存在undefined、null、0、false等数据时会中断遍历）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, a; a = arr[i++];) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-使用-amp-amp-替代单一条件判断"><a href="#9-使用-amp-amp-替代单一条件判断" class="headerlink" title="9. 使用 &amp;&amp; 替代单一条件判断"></a>9. 使用 <code>&amp;&amp;</code> 替代单一条件判断</h2><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你可能这样写过</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">token</span>) &#123;</span><br><span class="line">    <span class="built_in">login</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其实这样也可以</span></span><br><span class="line">!<span class="built_in">token</span> &amp;&amp; <span class="built_in">login</span>();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">token</span> || <span class="built_in">login</span>();</span><br></pre></td></tr></table></figure>
<h2 id="10-检测-对象-数组-中是否有指定-属性-元素"><a href="#10-检测-对象-数组-中是否有指定-属性-元素" class="headerlink" title="10. 检测 对象/数组 中是否有指定 属性/元素"></a>10. 检测 对象/数组 中是否有指定 属性/元素</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CURD = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    <span class="keyword">delete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    edit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"add"</span> <span class="keyword">in</span> CURD);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"find"</span> <span class="keyword">in</span> CURD);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 误 */</span></span><br><span class="line"><span class="comment">// var arr = [1, 2, 3];</span></span><br><span class="line"><span class="comment">// console.log(1 in arr);  // true</span></span><br><span class="line"><span class="comment">// console.log(6 in arr);  // false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>谢谢 @zaaack[zaaack] 指正，<strong>数组的存在检测实质上是检测的是数组下标</strong></p>
</blockquote>
<h2 id="11-通过闭包调用setTimeout"><a href="#11-通过闭包调用setTimeout" class="headerlink" title="11. 通过闭包调用setTimeout"></a>11. 通过闭包调用setTimeout</h2><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">for(<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) &#123;</span></span><br><span class="line">    setTimeout(<span class="name">function</span>()&#123;</span><br><span class="line">        console.log(<span class="name">i</span>)<span class="comment">;  // 10 10 10 ...</span></span><br><span class="line">    &#125;,<span class="number">500</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(<span class="name">var</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) &#123;</span></span><br><span class="line">    (<span class="name">function</span>(<span class="name">i</span>)&#123;</span><br><span class="line">        setTimeout(<span class="name">function</span>()&#123;</span><br><span class="line">            console.log(<span class="name">i</span>)<span class="comment">;  // 0 1 2 3 ...</span></span><br><span class="line">        &#125;,<span class="number">500</span>)</span><br><span class="line">    &#125;)(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-To-be-continue…"><a href="#12-To-be-continue…" class="headerlink" title="12. To be continue…"></a>12. To be continue…</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>好吧我很懒什么都没有弄_(:зゝ∠)_</title>
    <url>/Other/%E5%A5%BD%E5%90%A7%E6%88%91%E5%BE%88%E6%87%92%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%E5%BC%84-%D0%B7%E3%82%9D%E2%88%A0/</url>
    <content><![CDATA[<h2 id="练练手，真的什么都没有写-зゝ∠"><a href="#练练手，真的什么都没有写-зゝ∠" class="headerlink" title="练练手，真的什么都没有写(:зゝ∠)"></a>练练手，真的什么都没有写<em>(:зゝ∠)</em></h2>]]></content>
  </entry>
</search>
